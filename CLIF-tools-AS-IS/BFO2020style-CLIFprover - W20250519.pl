/* History
2024-01-15: First implementation, very incomplete!
*/
:-set_prolog_flag(stack_limit, 2_147_483_648).
:-use_module(library(pure_input)).
:-discontiguous t/1, c/1.

%% change back for debugging
:-style_check(-singleton).

:-dynamic	
	%% Data structures for the reasoning algorithms 
		toprove/1,		%% Name of the ontology/data to test consistency of with the base ontologies.
		pas/1,			%% ascending passive set ordering for given clause selection, each element of form [N1,N2]
						%	N1=order
						%	N2=clause ID
		clause/4,		%% individual clauses
						%	arg1=globally unique ID for the clause (integer)
						%	arg2=[n1,n2] where n1 = number of terms in the disjunction list, n2 = argument depth
						%	arg3=list of disjunctions
						%	arg4=any off
						%		[e, L] if clause is e(liminated) with conditional literal list L 
						%		[] if unconditional, or 
						%		list of literals when conditional clause
		processed/4,	%% states clause to have been processed using certain inferences
						%	arg1=clause ID
						%	arg2=inference name
						%	arg3=inference parameters (list)
						%	arg4=status of the clause counter prior to inference
		vmax/1,			%% number of reserved variable proxies
		clausedat/7,	%% use_stats on clause
						%	arg1=clause ID
						%	arg2=list depth of disjunctions (0=no function, 1 = 1 function, 2 = function in function, ...
						%	arg3=number of distinct variables
						%	arg4=origine
						%		o: ontology
						%		d: data (from input file) or claim (from FOL axioms in parser init declared as claims)
						%		i: inference
						%		t: trial attempt
						%	arg5=function recursion level
						%	arg6=given clause preference index
						%	arg7=value not assigned
		stopped/1,		%% unsaturated termination of saturation algorithm
						%	arg1=reason for termination
						%		[inc, CID]=inconsistency found, CID = ID of empty clause
						%		[for]=forced by threshold setting
			negax/3,	%% input from ...-nsat.txt generated by BFO2020-styleCLIFparser.pl
						%	arg1=unique clause number in input file (integer)
						%	arg2=axiom ID as provided in CLIF file (string)
						%	arg3=list of disjuncted literals, each literal formatted as a list with following elements:
						%		1: integer 0 or -1 for true or false resp.
						%		2: predicate name (including 'identical') as in CLIF file outdiscourse
						%		3: arguments as required by predicate
			posax/4,	%% input from ...-cf.txt generated by BFO2020-styleCLIFparser.pl
						%	arg1=unique clause number in input file (integer)
						%	arg2=list depth (integer) of arg4
						%			2 = no skolem function in the clause
						%			5 = skolem function present with no deeper skolem function as argument
						%	arg3=axiom ID as provided in CLIF file (string)
						%	arg4=list of disjuncted literals, each literal formatted as a list with following elements:
						%		1: integer 0 or -1 for true or false resp.
						%		2: predicate name (including 'identical') as in CLIF file outdiscourse
						%		3: arguments as required by predicate

			uterm/2,	%% unique term list
						%	arg1=ID
						%	arg2=term
			p_occ/3,	%%	index of literals with specific predicate 
						%	arg1=predicate name
						%	arg2=unique ID (integer)
						%	arg3=pair [OLN,OLP] of ordered lists containing all clauses in which arg1 appears as
						%		negative or positive literal resp., each element of these lists of the form [L,CN,P], where:
						%		L  = length of the clause in which the atom appears
						%		CN = negative clause ID
						%		P  = position of the literal in the disjunction list of clause CN
			literal/10,	%% index on single literals
						%	arg1=term of the literal as [predicate|argument-list]
						%	arg2=0 when true or -1 when false in disjunction <arg4> derived form axiom <arg5>
						%	arg3=number of disjunctions in clause
						%	arg4=unique clause number	(=arg1 in clause/4)
						%	arg5=list of variables in clause, may be [].
						%	arg6=unique literal occurrence ID
						%	arg7=position in the clause (first = 1)
						%	arg8=deepest function embedding
						%	arg9=deepest function recursion
						%	arg10= -N, where N is number of data constants in literal
			argument/7,	%% info on individual argument appearing in predicates
						%	arg1=argument (Prolog atom or function)
						%	arg2=weight calculated on arg5
						%	arg3=function embedding level
						%	arg4=function recursion level
						%	arg5=number of different variables the argument includes
						%	arg6=nested multiset representation
						%	arg7=unique ID
			argum/6,	%% index on predicate arguments in clauses
						%	arg1=argument
						%	arg2=clause ID
						%	arg3=nth1 argument position in literal
						%	arg4=unique literal occurrence ID (= arg6 in literal/10)
						%	arg5=function embedding level
						%	arg6=function recursion level
			axiom/1,	%% axiom identifier
			inv/3,		%% fol_atom replacement based on terminological equivalence
						%	arg1=axiom index
						%	arg2=literal to be replaced with arg3
						%	arg3=literal 		
			ontology/1,	%% ontology identifier
			pp/2,		%% predicate pattern
			fp/5,		%% function pattern
						%	arg1=arity order (integer)
						%	arg2=non-skolem or skolem (0 or 1) 
						%	arg3=occurrences
						%	arg4=function-name
						%	arg5=arity
			opp/4,		%% ontology predicate name
						%	arg1=arity
						%	arg2=predicate name
						%	arg3=total number of occurrences in clause set
						%	arg4=number of occurrences in clause set in negative literal
			oc/2,		%% constant appearing as predicate argument only in ontology
						%	arg1=occurrence
						%	arg2=constant
			dc/2,		%% constant appearing as predicate argument only in input data
						%	arg1=occurrence
						%	arg2=constant
			odc/2,		%% constant used in ontology AND data
			dp/1,		%% data predicate name
			no_inf/1,	%% "don't use posax" semafoor
						%	arg1=posax ID not to use for inferencing
	%% Term ordering
		%% categories for term ordering
			vrp/2,		%	variable proxies
			cdp/2,		%	constants only used in data and/or toprove input
			cdo/2,		%	constants used in both base theory and data input
			cpp/2,		%	constants only used in base theory
			fdp/2,		%	non-skolem functions only used in data and/or toprove input
			fsp/2,		%	skolem functions only used in toprove input
			pdo/2,		%	base theory predicate names used in data and toprove input
			fdo/2,		%	functions used in both base theory and data input 
			foo/2,		%	non-skolem functions only used in base theory 
			fso/2,		%	skolem functions only used in base theory 
			fuf/2,		%	function symbol of the only unary input function if any at all
			ide/2,		%	'identical'
			pnd/2,		%	predicate names not in pdo
			pno/2,		%	predicate names not in base theory
		%% Clause and clause component orderings
			c_ord/5,	%% multi-set representation of clause
						%	arg1=clause weight
						%	arg2=clause ID
						%	arg3=g(round clause based) or v(ariable based)
						%	arg4=multiset representation, sorted descending
						%	arg5=position of literals in order of arg4
			c_dat/5,	%% various clause attributes for inference efficiency
						%	arg1=clause ID
						%	arg2=clause type
						%		b(ase)
						%		i(nference)
						%		t(rial attempt)
						%		e(liminated)
						%		s(et of support)
						%	arg3=number of positive literals
						%	arg4=number of negative literals
						%	arg5=recursion level of skolem function with highest recursive embedding in clause literal
			c_atom/6,	%% a formula of the form [predicate_name|argument_list] with additional data
						%	arg1=multiset ordering value ("weight")
						%	arg2=the formula
						%	arg3=unique ID
						%	arg4=multiset representation
						%	arg5=string representation
						%	arg6=g(round clause based) or v(ariable based)
			l_arg/6,	%% as c_atom, but for arguments of literals
			l_arg_d/4 ,	%% attributes of the argument of a literal
						%	arg1=argument ID (= arg3 of l_arg/6)
						%	arg2=maximum functor recursion level (1 = no recursion)
						%	arg3=maximum other embedded token recursion level
						%	arg4=s(skolem functor) or n(on-skolem function)
			f_arg/3,	%% argument of function
						%	arg1=function argument
						%	arg2=g(round clause based) or v(ariable based)
						%	arg3=unique ID of function argument over clause set
			atc/5,		%% atom-clause index
						%	arg1=atom unique ID ( = c_atom/6 arg3 )
						%	arg2=clause unique ID ( = clause/4 arg1)
						%	arg3=position of literal in clause
						%	arg4=1 or 0 whether the literal is negative or positive
						%	arg5=1 or 0 whether it is an identity atom
			latc/4,		%% index of literal arguments to clause
						%	arg1=unique ID of literal argument ( = l_arg/6 arg3)
						%	arg2=clause ID
						%	arg3=position of literal in clause
						%	arg4=position of argument in literal
			fatc/5,		%% index of function argument to clause
						%	arg1=unique ID of function argument ( = f_arg/3 arg3)
						%	arg2=position vector of function argument in function (recursive function embedding)
						%		 (1 = first after 'skN')
						%	arg3=position of argument in literal (1 = first after predicate name)
						%	arg4=position of literal in clause
						%	arg5=Clause ID
			sor/3,		% symbol rank (symbol = predicate name or function name or skolem name or constant
						%	arg1=symbol
						%	arg2=what it is used for, options being:
						%		c = constant
						%		f = function
						%		p = predicate
						%		i = identity predicate
						%	arg3=symbol rank as atom
			padl/1,		% substitution for variables in multiset representation
			limits/1,	% max values for round of inferencing 
						%	arg2=[	max clause weight,
						%			max clause depth
						%			max skolem recursion
						%			max clause length
						%			max number of positive literals
						%			max number of neg literals	]

			term_ord/8,	% ordering info for literals
						%	arg1=position of term in clause (= arg7 in literal/10)
						%	arg2=unique TermId of the clause (= arg6 in literal/10)
						%	arg3=s/g-number representation of the term
						%	arg4=sum of multiset members
						%	arg5=predicate name number 
						%	arg6=list depth (1 = not embedded multiset)
						%	arg7=list of argument maxes
						%	arg8=the literal's truth value number (-1 (False) = 2, 0 (True) = 1)
			lito/1,		% ordered ascending set of literals (positive and negative)
						%	each element: to(W,TD,PN,TM,NT,TFO), where:
						%		W	= term_ord/8 arg4
						%		TD	= term_ord/8 arg6
						%		PN	= term_ord/8 arg5
						%		TM	= term_ord/8 arg7
						%		NT	= term_ord/8 arg3
						%		TFO	= term_ord/8 arg8
			lico/3,		% ordering of literals within clause
						%	arg1=Clause ID
						%	arg2=list of literal info in descending order of weight, each element being:
						%		[W, P] with
						%			W = position of the literal in the literal ordering 
						%			P = position of the literal in the clause
						%	arg3=sum of Ws of arg2
		
			cl_stata/2,	%% reason for active status of clause
						%	arg1=clause ID
						%	arg2=[reason ...]
						%		Reasons in use:
						%			[ont_clause,NP,A,B]	-> clause from ontology
						%				NP = from (n)egax or (p)osax
						%				A = clause number in -ax file
						%				B = axiom ID
						%			[replf,N, F] -> result from eliminating negated facts from disjunctions
						%				N = unique ID of replaced clause 
						%				F = unique ID of unit clause that was negated in clause N
						%			[repli,N, A] -> result from eliminating negated identity from disjunctions
						%				N = unique ID of replaced clause 
						%				A = identity that was negated in clause N
						%			[subst, CID, N] -> instantiated clause with term
						%				CID = clause ID from clause(CID,...) that was instantiated
						%				N = unique ID from f(_,N,_,_)
						%			[d_clause,N] -> data input of disjunctions
						%				N = unique ID for disjunction input clause. NOT THE SAME as clause ID in clause(ID,_...)
						%			[resolution, CID, P, CIDA, Pa] -> resolution
						%				CID = unique ID of first clause
						%				P = position in CID of literal used for resolution
						%				CIDA = unique ID of second clause 
						%				Pa = position in CIDA of literal used for resolution
						%			[factoring, N3, Vout] -> clause simplification through factoring
						%				N3 = unique ID of simplified clause
						%				Vout = list of mgu's consecutively used for factoring
						%			[red, Reason] -> clause reduction by removing redundant literals
						%				Reason = list with reasons for each literal removed:
						%					[dup, P1]	= removal of duplicated literal P1
						%					[nuc, [C1, C2]]	= removal of unit clause C2 with opposite truth value in C1
						%					[nid, L]		= literal denying of true identity
			cl_stati/2,	%% reason for inactive status of clause
						%	arg1=clause ID
						%	arg2=[reason ...]
						%		Reasons in use:
						%			[inverse] -> clause is part of a pure terminological axiom declaring inverse relation
						%			[no_inf] -> the input clause has a pos literal never used negative in the clause set
						%			[empty] -> the input clause did not contain a disjunction
						%			[tautology, P]
						%				P = explanation of the nature of the tautology
						%			[dbl,ID2] -> the clause is a Prolog variant of clause ID2
						%			[inv_repl_e, NCID, TAX] ->	clause replaced by clause NCID, the least used terminological
						%										relation being replaced with its inverse as defined in axiom TAX
						%			[subsumed_by, S] -> clause ID is subsumed by more general clause S
						%			[red, Reason] --> removal of redundant literal, with Reason being a list 1..n of:
						%				[dup, P1] --> duplication of literal P1
						%				[nuc, C, CS] --> C contains the anti-TF literal of unit clause CS
						%				[nid, L] --> a literal identity is negated
						%			[elimf,N] -> result from eliminating negated facts from disjunctions
						%				N = unique fact ID from f(_,N,_,_)
						%			[elimi,A] -> result from eliminating negated '(A,A)' from disjunctions
						%				A = argument whose identity is negated
						%			[f,N] -> clause inactivated because of fact in disjunctions
						%				N = unique ID of fact(_,N,_) in disjunctions
						%			[identity, I] -> clause inactivated because of identity in disjunctions
						%				I = argument with stated identity
						%			[uc,N] -> unit clause inactivated
						%				N = unique ID of f(_,N,_,_) that was generated because of unit clause
						%			[ec] -> empty clause = inconsistency
						%			[resolved_into, C, FID] -> resolution
						%				C = clause ID
						%				FID = fact id of fact used for resolution
			theory/1,	%% clause number of last clause generated from ontology
			toc/1,		%% clause number of last clause generated from ontology and data input
			c/1,		% input data: list of disjunctions
			t/1,		% single fact
			f/4,		%% fact
						%	arg1=factual expression: [0/-1|[PredicateName|[Args]]]
						%	arg2=unique fact identical
						%	arg3=support
						%		[uc, N] : fact derived from unit clause with ID N
						%	arg4=skolem depth
			farmed/3,	%% list of clauses farmed with term
						%	arg1=unique term ID
						%	arg2=term
						%	arg3=list of clause IDs
			resolved/4,	%% keeps track of which clauses were used in resolution
						%	arg1=ID of first clause to which resolution has been applied 
						%	arg2=position of first clause's literal to which resolution has been applied
						%	arg3=ID of second clause to which resolution has been applied 
						%	arg4=position of second clause's literal to which resolution has been applied
			identity/3,	%% track keeper of identities
						%	arg1=literal selected NOT to be used in clauses
						%	arg2=literal selected to be used in clauses
						%	arg3=fact ID which established identity
			counter/2,	%% counter for various data items
						%	arg1=counter name
						%	arg2=counter value
						% counters in use
						%	toid		  	: unique literal ID for occurrence in clause
						%	term		  	: unique term ID
						%	clause		  	: unique clause ID 
						%	d_clause	  	: unique ID for data clauses
						%	facts 		  	: unique ID for f/3
						%	fol_atom	  	: unique ID for FOL atoms
						%	pred([O,P,T,A]) : occurrence of predicate name (P) in pos. or neg. literal (T) and its (A)rity
						%					  with 'O' being 'd' or 'o' whether form data or ontology origine
						%	oc(N)		  	: N being an ontology constant but not a skolem function name
						%	sk(A,N)		  	: skolem function with A full name and N only the corresponding integer
						%	c_atom		  	: unique ID for [P|Args] formula
						%	l_arg		  	: unique ID for arguments of literals
						%	f_arg		  	: unique ID for arguments of functions
						%	frl				: function recursion level
			inc/1,		%% inconsistency marker
						%	Arg1 = list of axiom IDs leading to inconsistency with input, [] = no inconsistency
			maxdisl/1,	%% maximum clause length in input
	%% Movable threshold for given clause selection optimization
		threshold/3,	% 	arg1=allowed clause length after resolution
						% 	arg2=allowed recursion level of functions in functions (e.g. [sk1, ..., [sk4, ...]]  )
						% 	arg3=allowed auto-recursion level of function		   (e.g. [sk2, ..., [sk2, ...]]  )

	%% Temporary data structures

	%% Inference control
		puc_start/1,	% CID from which propagate_positive_unit_clauses/0 should start
						
	%% From prover-init file:
		project/1,			% project name for cf and nsat files serving as input
		max_threshold/3,	% maximum threshold levels to terminate prover once one met. Args: same as threshold/3
		w_threshold/3,		% weight of max_threshold values
		bws/1,				% type of clauses allowed to be backward simplified
		opr/1,				% order of ground input symbol types
		strategy/1,			% strategy for reasoning
		db_ratio/2,			% sets the ratio of depth-first, breadth-first.
							%	arg1=number of cycles depth- and breadth-first together
							%	arg2=number of depth-first cycles
							%   for example: db_ratio(7,5) indicates 5 depth first cycles followed by 2 breadth-first 
		inputdata/1.
		

:-writeln("BFO2020 Style CLIF prover, VERY PRELIMINARY AND INCOMPLETE Version April 23, 2025").
:-writeln("NOT FOR DISTRIBUTION !!!").
:-writeln("Copyright: Werner Ceusters. All rights reserved.").

:- include("CLIFproverinit.txt").			%% contains input- and output parameters

%% ------------
%% Main process
%% ------------

run :-	time(runit),
		get_single_char(_),halt,!.

runit:-	assert(inc([])),						% set inconsistency marker to empty
		assert(maxdisl(0)),						% set max clause length to 0
		writeln("Reading ..."),
		load_ontologies,						% import the posax-clauses
		findall( X, posax(X,_,_,_), Xs),		% collect all rule IDs of posax-clauses in Xs
		length(Xs, Lx),							% determine Xs' length
		asserta(theory(Lx)),					% store count in memory, i.e. number of clauses from the ontologies and toprove
		assert(counter(clause, Lx)),			% set the clause-counter to number of theory clauses
		load_data,								% load ground data and additional disjunctions
		toprove(TP),							% retrieve the name of the ontology component to prove, if any
		prepare_data_clauses(TP),				% transform data clauses to posax-format
		writeln("Creating term simplification ordering ..."),
		opr(OPR),								% retrieve the rank-order categories for term ordering
		component_counts(OPR, TP, TotT),		% compute certain ontology content counts for term ordering
		atom_ordering(OPR, TotT),				% create the term ordering
		obsolete_clauses,						% remove certain obsolete clauses
		writeln("Indexing ..."),				% build indexes
		input_clauses_analyzed(TP),				% ...
		simplify_clause_set(End1),
%%trace,
		( integer(End1)					% if input simplification resulted in an empty clause
			-> !, empty_clause(End1)	% 	compute inconsistency proof
		; 								% otherwise
		  writeln("Inferencing ..."),	%	perform inferences until stop condition reflected in 'End'
		  main_inference(End),			%	...
		  ( End == none
			-> writeln("No active clauses found!")
		  ;	End == 0					%	case 1: input is satisfiable
			-> writeln("Satisfiable")	%		...
		  ; integer(End)				%	case 2: empty clause derived
			-> empty_clause(End)		%		compute proof
		  ; writeln("Undecided")		%	case 3: inference ended on stop condition  %% to be done
		  )
		).
runit:-!.


%% First reading and standardization of input data 

% Load ontologies from input file
load_ontologies:-
	style_check(-singleton),
	project(P),								% Obtain projectname prefix from proverinit-file
	atomic_list_concat([P,"-cf.txt"],F1),	% Compose the filename of the positive axiom file
	consult(F1),							% Load it
	!.

% Read init-file to identify data files to load
load_data:-
	(	inputdata(Data),
		expand_file_name(Data,Input),
		(	Input = [],
			writeln("Specified inputdata do not exist. Check CLIFproverinit.txt for the 'inputdata(\"...\")' parameter."),
			!,fail
		;	style_check(-singleton),
			consult_input_files(Input)
		)
		;	writeln("No input data specified. Check CLIFproverinit.txt for the 'inputdata(\"...\")' parameter."),
			!,fail
		),!.

% Load the data files
consult_input_files([]):-style_check(+singleton),!.
consult_input_files([H|T]):-
	consult(H),
	!,consult_input_files(T).


% Read input file, loaded by means of include
% Variables:
%	i1:	name of the data/toprove component
% Read unconditional data input
prepare_data_clauses(TP):-
	retract(t(X)),									% BPT1: pick data input clause with single term
 	hyphened_terms_to_atoms(X,[],X1),				% atomize all terms with hyphens
	list_depth(X, DX),								% determine the recursive depth of the deepest function, if any at all
	DDX is DX - 1,									% adjust depth for input format
	increment(d_fact, D),							% create ID for the fact
	string_concat(TP,"-d_f-", S),
	string_concat(S, D, SD),
	increment(clause, CID),							% increment the clause counter
	assertz_once(posax(CID,DDX,SD,[X1])),			% store the input according to the posax clause structure
	fail.											% backtrack to BPT1 to pick next single term input until no more left
% Read input disjunctions
prepare_data_clauses(TP):-
	retract(c(X)),									% BPT1: pick data input clause with disjunction of literals
	atomize_data_clause(X,[],Y),					% atomize in all literals all terms with hyphens
	list_depth(Y, DX),								% proceed as above
	DDX is DX - 2,
	increment(d_clause, D),	
	string_concat(TP,"-d_c-", S),
	string_concat(S, D, SD),
	increment(clause, CID),
	assertz_once(posax(CID,DDX,SD,Y)),
	fail.
prepare_data_clauses(_):-!.


atomize_data_clause([],In,Out):-
	sort(In, Out),!.
atomize_data_clause([H|T],In,Out):-
	hyphened_terms_to_atoms(H,[],HOut),
	!,atomize_data_clause(T,[HOut|In],Out).


hyphened_terms_to_atoms([],In,Out):-
	reverse(In,Out),!.
hyphened_terms_to_atoms([H|T],In,Out):-
	is_list(H),
	hyphened_terms_to_atoms(H,[],H1),
	hyphened_terms_to_atoms(T,[H1|In],Out).
hyphened_terms_to_atoms([H|T],In,Out):-
	compound(H),
	compound_name_arity(H,(-),_),
	term_to_atom(H,H1),
	!,hyphened_terms_to_atoms(T,[H1|In],Out).
hyphened_terms_to_atoms([H|T],In,Out):-
	\+number(H),\+compound(H),\+atom(H),\+var(H),
	term_to_atom(H,H1),
	!,hyphened_terms_to_atoms(T,[H1|In],Out).
hyphened_terms_to_atoms([H|T],In,Out):-
	!,hyphened_terms_to_atoms(T,[H|In],Out).

	

% Perform basic counts of of components for term ordering
% Variables:
%	i1:	list of rank-order categories for term ordering
%	i2:	name of toprove and data components 
%	o3: total number of terms and proxies for variables to be ordered
component_counts(OPR, TP, TotT):-
 % Compute 'safe' number of variable proxies to be reserved
	findall(
		TVL,
		( posax(_,_,_,Dis),
		  term_variables(Dis, TV),
		  length(TV, TVL) ),
		TVLS),
	sort(0, @>, TVLS, [Vmax|_]),
	Vmost is Vmax^2,
	assert(vmax(Vmost)),
 % Extract the predicate names
	findall( 
	  [OR,Pred,TF,AR],							% Count the number of occurrences of predicate names in pos and neg literals resp.
	  (	posax(_,_,Source,Dis),					% BPT1: for all posax() structures
		split_string(Source,"-","",[O|_]),		% split the source string
		( O == TP								% set predicates from components to prove for consistency apart
			-> OR = d
		; OR = o
		),
		member([TF|[Pred|Args]], Dis),			% BPT2: for all literals in the selected posax()-structure
		length(Args, AR),						% while retrieving predicate arity as well
		increment(pred([OR,Pred,TF,AR]),_) ),
	  Preds),
	sort(Preds, PredsS),
	maplist(create_opp, PredsS),				% store for each predicate: arity, and tallies of total and neg. uses
	findall([AR,NT,Pred], 						% find all base theory predicates used in data/toprove clauses
			( member([d,Pred,_,AR],PredsS),
			  member([o,Pred,_,AR],PredsS),
			  opp(AR, Pred, Tot, _),
			  NT is 0 - Tot),
			PDO),							
	sort(PDO, PDOs),
	nth1(Npdo, OPR, pdo),
	asserta(pdo(Npdo, PDOs)),
	findall([AR,NT,Pred], 						% find all predicates only used in base theory
			( member([o,Pred,_,AR],PredsS),
			  \+member([d,Pred,_,AR],PredsS),
			  opp(AR, Pred, Tot, _),
			  NT is 0 - Tot),
			PND),							
	sort(PND, PNDs),
	nth1(Npnd, OPR, pnd),
	asserta(pnd(Npnd, PNDs)),
	findall([AR,NT,Pred], 						% find all predicates not used in base theory
			( member([d,Pred,_,AR],PredsS),
			  \+member([o,Pred,_,AR],PredsS),
			  opp(AR, Pred, Tot, _),
			  NT is 0 - Tot),
			PNO),							
	sort(PNO, PNOs),
	nth1(Npno, OPR, pno),
	asserta(pno(Npno, PNOs)),

 % Extract the function names
	findall(									% retrieve all functions, including skolem functions
	  Out,
	  (	posax(_,_,Source,D),					% BPT1 for this search
		split_string(Source,"-","",[O|_]),		% split the source string
		( O == TP								% set predicates from components to prove for consistency apart
			-> OR = d
		; OR = o
		),
		member([_|[_|X]],D),					% BPT2: for each literal's predicate arguments in the discjunction list
		member(E,X),							% BPT3: for each list in the arguments (lists at this level are functions)
		is_list(E),
		rec_function([E], OR, [], Out) ),		% collect the functions in Out
		Fs),
	findall(L, ( member(X, Fs),					% bring all functions in one list
				 member(L, X) ),
			LS),
	sort(LS, Lss),
	findall(F, member([_,F,1], Lss), UnF),		% Check whether there is only one unary function
	(	length(UnF, 1)
			-> 	nth1(Nfuf, OPR, fuf),
				asserta(fuf(Nfuf, [UnF]))
	;	true
	),
	findall([ARM,NT,Func], 						% find all non-skolem functions only used in data and/or toprove input
			( member([d,Func,AR],Lss),
			  \+member([o,Func,AR],Lss),
			  ( atom_concat(sk,Sk,Func), 		% don't include if skolem function
			    atom_number(Sk,_)
					-> fail
			  ; true
			  ),
			  ( AR == 1							% As in Prover9, function arity 2 < function arity 1
					-> ARM = 2
			  ; AR == 2
					-> ARM = 1
			  ; ARM = AR
			  ),
			  counter(func([d,Func,AR]),Tot),	% Higher occurrence, then smaller, so take negative of count 
			  NT is 0 - Tot),
			FDP),
	sort(FDP, FDPs),
	nth1(Nfdp, OPR, fdp),
	asserta(fdp(Nfdp, FDPs)),
	findall([ARM,NT,Func], 						% find fsp:	skolem functions only used in toprove input
			( member([d,Func,AR],Lss),
			  \+member([o,Func,AR],Lss),
			  ( atom_concat(sk,Sk,Func), 		% don't include if skolem function
			    atom_number(Sk,_)
					-> true
			  ; fail
			  ),
			  ( AR == 1							% As in Prover9, function arity 2 < function arity 1
					-> ARM = 2
			  ; AR == 2
					-> ARM = 1
			  ; ARM = AR
			  ),
			  counter(func([d,Func,AR]),Tot),	% Higher occurrence, then smaller, so take negative of count 
			  NT is 0 - Tot),
			FSP),
	sort(FSP, FSPs),
	nth1(Nfsp, OPR, fsp),
	asserta(fsp(Nfsp, FSPs)),
	findall([ARM,NT,Func], 						% find fdo:	functions used in both base theory and data input
			( member([d,Func,AR],Lss),
			  member([o,Func,AR],Lss),
			  ( AR == 1							% As in Prover9, function arity 2 < function arity 1
					-> ARM = 2
			  ; AR == 2
					-> ARM = 1
			  ; ARM = AR
			  ),
			  counter(func([o,Func,AR]),T1), 
			  counter(func([d,Func,AR]),T2), 
			  NT is 0 - T1 - T2),				% Higher occurrence, then smaller, so take negative of count
			FDO),
	sort(FDO, FDOs),
	nth1(Nfdo, OPR, fdo),
	asserta(fdo(Nfdo, FDOs)),
	findall([ARM,NT,Func], 						% find foo:	non-skolem functions only used in base theory
			( member([o,Func,AR],Lss),
			  \+member([d,Func,AR],Lss),
			  ( atom_concat(sk,Sk,Func), 		% don't include if skolem function
			    atom_number(Sk,_)
					-> !,fail
			  ; true
			  ),
			  ( AR == 1							% As in Prover9, function arity 2 < function arity 1
					-> ARM = 2
			  ; AR == 2
					-> ARM = 1
			  ; ARM = AR
			  ),
			  counter(func([o,Func,AR]),Tot),	% Higher occurrence, then smaller, so take negative of count 
			  NT is 0 - Tot),
			FOO),
	sort(FOO, FOOs),
	nth1(Nfoo, OPR, foo),
	asserta(foo(Nfoo, FOOs)),
	findall([ARM,NT,Func], 						% find fso:	skolem functions only used in base theory
			( member([o,Func,AR],Lss),
			  \+member([d,Func,AR],Lss),
			  ( atom_concat(sk,Sk,Func), 		% don't include if skolem function
			    atom_number(Sk,_)
					-> true
			  ; !,fail
			  ),
			  ( AR == 1							% As in Prover9, function arity 2 < function arity 1
					-> ARM = 2
			  ; AR == 2
					-> ARM = 1
			  ; ARM = AR
			  ),
			  counter(func([o,Func,AR]),Tot),	% Higher occurrence, then smaller, so take negative of count 
			  NT is 0 - Tot),
			FSO),
	sort(FSO, FSOs),
	nth1(Nfso, OPR, fso),
	asserta(fso(Nfso, FSOs)),

 % Extract the constants
	findall( 
	  [OR,Const],								% Count the number of various constants in clause set
	  (	posax(_,_,Source,Dis),					% BPT1: for all posax() structures
		split_string(Source,"-","",[O|_]),		% split the source string
		( O == TP								% set predicates from components to prove for consistency apart
			-> OR = d
		; OR = o
		),
		member([_|Predicate], Dis),				% BPT2: for each predicate in Dis
		sub_term(List, Predicate),				% BPT3: for each sub_term in the predicate
		is_list(List),							%	... that is a list
		length(List,LL),						%	... that list having length LL
		nth1(N,List,Const),						% BPT4: ... and for each position in that list
		N > 1,									%			... except the 1st one (which is a function name or predicate name)
		N =< LL,
		atom(Const),							%		... that is an atom
		increment(const([OR, Const]), _) ),
	  Consts),
	sort(Consts, ConstsS),
	findall([NT,C],		 						% find all base theory constants used in data/toprove clauses
			( member([d,C],ConstsS),
			  member([o,C],ConstsS),
			  counter(const([d,C]),ND),
			  counter(const([o,C]),NO),
			  NT is 0 - ND - NO),
			CDO),							
	sort(CDO, CDOs),
	nth1(Ncdo, OPR, cdo),
	asserta(cdo(Ncdo, CDOs)),
	findall([NT,C],		 						% find constants only used in data/toprove clauses
			( member([d,C],ConstsS),
			  \+member([o,C],ConstsS),
			  counter(const([d,C]),ND),
			  NT is 0 - ND),
			CDP),							
	sort(CDP, CDPs),
	nth1(Ncdp, OPR, cdp),
	asserta(cdp(Ncdp, CDPs)),
	findall([NT,C],		 						% find constants only used in data/toprove clauses
			( member([o,C],ConstsS),
			  \+member([d,C],ConstsS),
			  counter(const([o,C]),ND),
			  NT is 0 - ND),
			COO),							
	sort(COO, COOs),
	nth1(Ncoo, OPR, coo),
	asserta(coo(Ncoo, COOs)),

 % position of identity
	nth1(Nide, OPR, ide),
	opp(_,identical,NI,_),
	asserta(ide(Nide, [[NI, identical]])),

 % compute total number of terms to be ordered
	total_terms(OPR,0,TotT),
	!.

% Compute total number of terms and variable proxies to be ordered
% Variables:
%	i1:	list of ordering categories
%	i2: number of terms/proxies counted thus far
%	o3: total number of counts
total_terms([],Total,Total):-!.
total_terms([vrp|T],In,Out):-			% deal with variables
	vmax(V),
	In2 is V + In,
	!,total_terms(T, In2, Out).
total_terms([H|T],In,Out):-				% deal with used term categories
	functor(Func, H, 2),					% create a predicate with as name the value of H and with 2 arguments
	call(Func),								% call the predicate
	arg(2, Func, List),						% retrieve the list specified in 2nd argument
	length(List, LL),
	In2 is LL + In,
	!,total_terms(T, In2, Out).
total_terms([_|T],In,Out):-				% deal with empty categories
	!,total_terms(T, In, Out).


% Extract functions from literals
% Variables:
%	i1: list of predicate argument lists
%	i2: indicates whether the arguments come from a literal in a theory clause or data/toprove clause
%	i3: in-accumulator
%	o4:	out-accumulator 
rec_function([], _, In, In).						% return result when done
rec_function([L|T], OR, In, Out):-					% pick first argument from the predicate
	nth1(1, L, Func, R),							% pick the first 
	(	atom(Func)									% it should be an atom, otherwise invalid clause
		 -> true
	;	write("Invalid predicate argument: "),		%% add program stop semafoor
		write_canonical(L),
		writeln(""),
		!,fail
	),
	length(R,RL),									% get the arity of the function
	increment(func([OR,Func,RL]),_),				% increment counter
	findall(NL, ( member(NL, R),					% find any deeper level lists which should be functions
				  is_list(NL) ), 
			NLS), 
	rec_function(NLS, OR, [[OR,Func,RL]|In], Out1),	% proceed with deeper level functions, if any
	rec_function(T, OR, Out1, Out).					% proceed with other lists
	


% Store for each predicate: arity, name, total occurrence, occurrence in negative literals
% Variable:
%	i1: list of predicate info
create_opp([_,Pred,_,AR]):-
	findall(P, counter(pred([_,Pred,0,AR]),P), Ps),	
	findall(N, counter(pred([_,Pred,-1,AR]),N), Ns),
	sum_list(Ps, P),
	sum_list(Ns, N),
	Tot is P + N,
	asserta_once(opp(AR, Pred, Tot, N)).


% Create numerical order for all atoms (constants, function names, predicate names)
% Variables:
%	i1: list of ordering categories
%	i2: total number of terms/proxies to order 
atom_ordering(OPR, TotT):-
	create_atom_order(OPR, [], Out),		% create the complete constant-ordering
	atom_number(Atom, TotT),				% convert this number to an atom
	atom_length(Atom, AL),					% obtain the number of characters
	length(PadL, AL),						% create list variable PadL with length AL
	maplist(=('0'), PadL),					% fill each element with '0'
	atomic_list_concat(PadL, SPad),			% create an atom out of the list elements
	assert(padl(SPad)),						% store it
	order_ds(Out, AL, sor, 1),				% build index sor/3 for atoms
	naming_check,
	!.



% Create the total atom order
% Variables:
%	i1:	list of categories for term ordering
%	i2:	in-accumulator for atoms/variable proxies
%	o3: out-accumulator
create_atom_order([],In,In):-!.
create_atom_order([vrp|R],In,Out):-
	vmax(VM),								% retrieve the 'safe' number of variable proxies
	numlist(1, VM, VL),						% fill an ascending list with the numbers 1 to VM as elements
	maplist(var_atom, VL, Atoms),			% create for each element a proxy atom 
	append(In, Atoms, NewIn),				% append the in-list with the newly created one
	!, create_atom_order(R, NewIn, Out).
create_atom_order([H|R],In,Out):-
	functor(Func, H, 2),					% create a predicate with as name the value of H and with 2 arguments
	sub_atom(H,0,1,_,S),					% unify S with the first character of the value of H
	call(Func),								% call the predicate
	arg(2, Func, List),						% retrieve the list specified in 2nd argument
	nth1(1, List, M),						% pick the first element, all elements being lists of the same length
	length(M, LM),							% determine this length
	maplist(atom_s(S, LM), List, Atoms),	% create Atoms as a list of the last elements of each List-element 
	append(In, Atoms, NewIn),				% append the two lists
	!, create_atom_order(R, NewIn, Out).
create_atom_order([_|R],In,Out):-			% if an ordering category does not exist, skip 'it'
	!, create_atom_order(R, In, Out).


% Aggregate each atom and its source into a pair
% Variables:
%	i1: the source
%	i2: the length of the list
%	i3: the list to pick the last element from
%	o4: the output pair
atom_s(S, LM, List, [S, Atom]):-
	nth1(LM, List, Atom).



% Create from an atom <I> a pair [v, v_<I>] 
% Variables:
%	i1:	the atom
%	o2:	the output pair
var_atom(I,[v,S]):-
	atom_concat(v_,I,S),!.


% Variables:
%	i1: list of data elements
%	i2: number of characters needed to represent the constant order
%	i3: name for storage
%	i4: order integer
order_ds([],_,_,_):-!.
order_ds([[S,A]|T], L, Name, Order):-
	pad_nat_num(Order, L, Padded),
	(	A == identical,							% do not include 'identical' in the predicate list for ordering
		S == p									% unless its determination is 'i'
			->	NewOrder = Order,
				true
	;	sor(A,p,_)
			-> NewOrder = Order
	;	OE =.. [Name, A, S, Padded],
		asserta(OE),
		NewOrder is Order + 1
	),
	!,order_ds(T, L, Name, NewOrder).


% Checks double use of names for predicates, constants, functions
naming_check:-				
	sor(A, S1, P1),			% BPT1: pick a name
	sor(A, S2, P2),			% BPT2: pick the name again
	S1 \== S2,				% continue if the category is different
	P2 @> P1,				% and the order of the 2nd > than the first (to prevent double reciprocal warnings)
	atomics_to_string(['Warning: atom ', A, ' used as (', S1, ') and (', S2, ')!'], S),
	writeln(S),
	fail.  
% Checks use of predicates not used in base theory
naming_check:-
	counter(pred([d,P,_,_]),_),		% BPT1: pick a predicate name used in data input
	\+counter(pred([o,P,_,_]),_),	% continue when the predicate is not used in the base theory
	atomics_to_string(['Warning: predicate ', P, ' found in data input but not in base theory!'], S),
	writeln(S),
	fail.  
naming_check.
	

%% Clause analysis and generation of indexes

% process all input clauses for retention/modification
% Variable:
%	i1: name of data/theorem to test
input_clauses_analyzed(TP):-
	retract(posax(ID, L, S, Dis)),				% BPT1: pick the clause with specified ID
	length(Dis, LS),							% compute number of disjunctions in the clause
	duplicate_term(Dis, DisD),
	split_string(S,"-","",[O|_]),				% split the source string
	assertz_once(axiom(S)),						% store the axiom denotator from which the clause originated
	assertz_once(ontology(O)),					% store the ontology name
	asserta(cl_stata(ID,[ont_clause,p,ID,S])),	% store the clause's source
	sort(Dis, DisS),
	( inv(S,_,_) ->								% if the input is from an axiom which is a pure terminological one 
	  asserta(cl_stati(ID, [inverse])),			% store inactivation reason as pure terminological clause
	  asserta(clause(ID,[LS,L],DisS,[e,[]]))	% store clause as eliminated one
	; (	no_inf(ID) ->							% if the input clause has a pos literal never used negative in the clause set
		asserta(cl_stati(ID, [no_inf])),		% store inactivation reason 
		asserta(clause(ID,[LS,L],DisS,[e,[]]))		% store clause as eliminated one
	  ; ( Dis == [] ->							% don't process empty input clauses
		  asserta(cl_stati(ID, [empty])),		% store inactivation reason
		  asserta(clause(ID,[LS,L],DisS,[e,[]]))		% store clause as eliminated one
		; (	tautology(DisD, RT) ->				% exclude clauses with tautologies
			asserta(cl_stati(ID, RT)),			% store inactivation reason
			asserta(clause(ID,[LS,L],DisS,[e,[]]))	% store clause as eliminated one
		  ; ( clause(ID2,LX,DisD,[]),			% find a non-eliminated unifying clause
			  clause(ID2,LX,DN,[]),				% take the original of the unified clause
			  duplicate_term(Dis, DisDD),		% duplicate the disjunction list of the clause under scrutiny
			  DisDD =@= DN ->					% if the disjunction lists are variants, the clause is a double to be excluded
			  asserta(cl_stati(ID,[dbl,ID2])),	% store inactivation reason
			  asserta(clause(ID,[LS,L],DisS,[e,[]]))	% store clause as eliminated one
			; inverse_relations_replaced(0,LS,DisS,OutR,[],TAX),	% replace least-used terminological literals, if any
			  ( TAX == []											% if there are none, 
				 -> asserta_once(clause(ID,[LS,L],OutR,[])),		%	create the clause as is
					NCID = ID
			  ; TAX \== []											% otherwise,
				 ->	asserta_once(clause(ID,[LS,L],DisS,[e,[]])),			% 	create the original clause as e(liminated)
					increment(clause, NCID),						%	create new clause ID
					asserta(cl_stati(ID, [inv_repl_e, NCID, TAX])),	% 	store its inactivation reason
					asserta_once(clause(NCID,[LS,L],OutR,[])),		%	store replaced clause
					asserta(cl_stata(NCID, [inv_repl_a, ID, TAX]))	%	store its activation reason
			  ),
			  ( TP == O -> SOS = s ; SOS = b ),			% determine whether clause belongs to set of support 
			    index_clause(NCID, OutR),
				add_clause_data(NCID,DisS,SOS,SOS,LS)
			)
		  )
		)
	  )
	),
	fail.
input_clauses_analyzed(_):-!.


% Variables:
%	i1: disjunction list
%	i2: reason for creation
%	i3: as what type of clause when limits/1 are not exceeded
%	i4: as what type of clause when at least one limits/1 threshold is exceeded
%	i5: condition list (arg4 in clause/4)
%	o6: clause ID
add_new_clause([Dis, Reason, Where1, Where2, Cond], CID):-
	increment(clause, CID),					% generate new clause ID
	length(Dis, CL),						% calculate clause length
	list_depth(Dis, DX),					% calculate clause depth
	DDX is DX - 2,							% adjust to make clauses with no functions in literals having depth 0 
	asserta_once(clause(CID, [CL, DDX], Dis, Cond)), 
	asserta(cl_stata(CID, Reason)),
	index_clause(CID, Dis),
	add_clause_data(CID, Dis, Where1, Where2, CL),
	!.

% Variables
%	++1:	clause ID
%	++2:	disjunction list
index_clause(C, Dis):-
	padl(PLL),								% retrieve the padding length for number representation
	ground_clause(Dis, OutG),				% make a ground copy of the disjunction list
	clause_literals(1, C, OutG, PLL, g),	% create clause indexes for grounded multiset representation
	clause_lt(C, g, MSRg, LPg),				% obtain the multiset representation and corresponding literal positions in descending order
	clause_weight(C, g, CWg),				% compute the weight
	asserta(c_ord(CWg, C, g, MSRg, LPg)),
	clause_literals(1, C, Dis, PLL, v),		% create clause indexes for variable based multiset representation
	clause_lt(C, v, MSRv, LPv),					% create clause multiset representation
	clause_weight(C, v, CWv),
	asserta(c_ord(CWv, C, v, MSRv, LPv)),
	!.


% Variables:
%	++1: clause ID
%	++2: disjunction list
%	++3: clause type within limits/1 thresholds
%	++4: ... outside ...
%	++5: clause length
add_clause_data(C, Dis, Where1, Where2, CL):-		%% some redundant variable passing. Optimize later
	clause(C, [CL, CD], _, _),
	c_ord(CWg, C, g, _, _),
	findall(_, member([0|_], Dis), PL),
	length(PL, PLL),
	NLL is CL - PLL,
	findall(X, ( latc(L, C, _, _),
				 l_arg_d(L, X, _, s) ),
			Xs),
	( Xs \== []
		-> max_list(Xs, M),
		   R is M - 1
	; Xs == []
		-> R = 0
	),
	( Where1 == Where2
		->	asserta(c_dat(C, Where1, PLL, NLL, R))
	; Where1 \== Where2,
	  limits([WC, DC, RC, LC, PoL, NeL])
		-> ( CWg =< WC,
			 CL =< LC,
			 R =< RC,
			 CD =< DC,
			 PLL =< PoL,
			 NLL =< NeL
				->	asserta(c_dat(C, Where1, PLL, NLL, R))
		    ; asserta(c_dat(C, Where2, PLL, NLL, R))
		   )
	),!.
		 

% create a clause's multiset representation
% Variables:
%	i1: clause ID
%	i2: computed (g)round or (v)ariable based
%	o3: multiset representation of clause as list with literals sorted in descending weight
%	o4: as o3 but literals referenced by their position in the clause
clause_lt(ID, GV, MSR, Plit):-
	findall( [MS, P],
			 ( atc(CAN, ID, P, TFA, _),
			   c_atom(_, _, CAN, _, S, GV),
			   atom_concat(S, TFA, MS) ),
			 MSO),
	sort(0,@>=,MSO,PairS),
	maplist(pair_list_split,PairS,MSR,Plit),
	!.

pair_list_split([A,B], A, B):-!.


% compute a clause's weight
% Variables:
%	i1: clause ID
%	i2: computed (g)round or (v)ariable based
%	o3: clause weight
clause_weight(ID, GV, CW):-
	findall( LW,								% find all weights satisfying:
			 ( atc(CAN, ID, _, TFA, _),			%	1) being related to an atom CAN of the clause with identifier ID
			   c_atom(AW, _, CAN, _, _, GV),	%	2) being computed by adding to the GV-based weight of the atom CAN ... 
			   LW is AW + TFA),					%	3) ... the value for the literal's truth/falsehood
			 LWS),
	sum_list(LWS, CW),!.						% return the sum of these weights as the clause weight GV-based

	

% Replace in clauses the least-used literals from terminological axioms with their most-used equivalent
%	e.g.: replace "[TF, environs, _A, _B]" with "[TF, 'occurs-in', _B, _A]"
% Variables: 
%	i1:	start position in the clause
%	i2:	number of literals in the clause
%	i3: original clause disjunction set 
%	o4: transformed disjunction set when at least one literal is the least-used one from a terminological axiom
%	i5:	in-accumulator for involved terminological axioms
%	o6:	out-accumulator
inverse_relations_replaced(Stop,Stop,Out,FOut,In,In):-			% return result when all literals processed
	sort(Out, FOut),!.
inverse_relations_replaced(Start, Stop, DisIn, DisOut, AxIn, AxOut):-
	nth0(Start, DisIn, [TF|[P|ArgP]], RP),						% pick the literal in 'Start' position, holding the others in 'RP'
	inv(Ax,[P|ArgP],[Q|ArgQ]),									% if the literal is a least-used terminological one
	NS is Start + 1,											%	increment position counter
	!,inverse_relations_replaced(NS, Stop, 
								 [[TF|[Q|ArgQ]]|RP], DisOut,	% replace the literal in input disjunction list
								 [Ax|AxIn], AxOut).				% add the involved axiom
inverse_relations_replaced(Start, Stop, DisIn, DisOut, A, B):-	% otherwise
	NS is Start + 1,											%	just increase the position counter
	!,inverse_relations_replaced(NS, Stop, DisIn, DisOut, A,B).	%	and recurs
	

% Stores unique FOL-atoms en index between atoms and clauses
% Variables
%	+1: position of literal in clause
%	+2:	Clause ID
%	+3:	disjunction list
%	+4:	padding atom for variables
%	+5: whether g(round) or v(ariable) based
clause_literals(_,_, [], _, _):-!.
clause_literals(I, ID, [[TF|[P|A]]|R], PadL, GV):-		% pick first literal on list
	( GV == g
		-> ( TF == '-1' -> TFA = 1; TFA = 0)			% to make neg literals bigger than their positive counterpart
	;  GV == v
		-> ( TF == -1 -> TFA = 1; TFA = 0)				% to make neg literals bigger than their positive counterpart
	),
	( P == identical									% mark whether the literal expresses identity
		->	IDM = 1
	; IDM = 0
	),
	( \+c_atom(_,[P|A],_,_,_,GV)						% if its atom cannot unify with a registered atom, the atom is 'new'
		->	numbered_ms([P|A],sor,PadL,[],Out),			%	compute its multiset representation
			mnld(Out, S, Sum),							%	compute its weight
			increment(c_atom, CAN),						%	create new c_atom ID
			asserta(c_atom(Sum,[P|A],CAN,Out,S,GV)),	%	store the atom
			asserta(atc(CAN, ID, I, TFA, IDM))			%	store the link to the corresponding literal in the clause
	; duplicate_term([P|A],[PD|AD]),					% if its atom can unify, duplicate it with fresh variables
	  findall( X,										%	find all ...
			   ( c_atom(_, [PD|AD], X, _, _, GV),		%		stored atoms that unify with the copied atom
			     c_atom(_, Orig, X, _, _, GV),			%		obtain the stored atom as it was before unification
				 Orig =@= [P|A] ),						%		enforce this original to be a Prolog 'variant' of the literal's atom
			   Xs),
	  ( Xs == []										% if the list is empty, it is a 'new' atom
		 ->	numbered_ms([P|A],sor,PadL,[],Out),			%	then do as above
			mnld(Out, S, Sum),
			increment(c_atom, CAN),
			asserta(c_atom(Sum, [P|A], CAN, Out, S, GV)),
			asserta(atc(CAN,ID,I,TFA,IDM))
	  ; Xs = [CAN]										% otherwise, create only the link between the clause and the existing atom
		 -> asserta(atc(CAN,ID,I,TFA,IDM))
	  )
	; true
	),
	literal_arguments(1, I, ID, A, PadL, GV),			% process all arguments of the atom
	function_arguments(1, I, ID, A, GV),				% process all functions, if any at all, used in these arguments
	IN is I + 1,
	!, clause_literals(IN, ID, R, PadL, GV).


% Build index of arguments used in literals
% Variables:
%	i1: position of argument in literal
%	i2: position of literal in clause
%	i3:	Clause ID
%	i4: argument list
%	i5:	padding atom for variables
%	i6: (g)round or (v)ariable based
literal_arguments(_, _, _, [], _, _):-!.				% procedure very similar to clause_literals
literal_arguments(AI, I, ID, [H|T], PadL, GV):-
	( var(H),											% can only occur for v-based
	  ( GV == g, writeln("GV error!") ; true )			%	so include this program verification test
		-> ( \+l_arg(_, H, _, _, _, v),				
			 var(H)
				-> increment(l_arg, LA),
				   concat('01',PadL,NP),
				   asserta(l_arg(1000,_,LA,[PadL],NP,v))
			; true
			)
	; \+l_arg(_,H,_,_,_,GV)
		->	numbered_ms([H],sor,PadL,[],O),
			mnld(O, S, Sum),
			increment(l_arg, CAN),
			asserta(l_arg(Sum,H,CAN,O,S,GV)),
			asserta(latc(CAN, ID, I, AI))
	; duplicate_term(H,HD),
	  findall( X,
			   ( l_arg(_,HD,X,_,_,GV),
			     l_arg(_,Orig,X,_,_,GV),
				 Orig =@= H ),
			   Xs),
	  ( Xs == []
		 ->	numbered_ms([H],sor,PadL,[],O),
			mnld(O, S, Sum),
			increment(l_arg, CAN),
			asserta(l_arg(Sum,H,CAN,O,S,GV)),
			asserta(latc(CAN, ID, I, AI))
	  ; Xs = [CAN]
		 -> asserta(latc(CAN, ID, I, AI))
	  )
 	; true
	),
	( is_list(H)
		-> 	f_recursion(H, FrecN, RrecN, FT),
			asserta_once(l_arg_d(CAN, FrecN, RrecN, FT))
	; true
	),
	AI2 is AI + 1,
	literal_arguments(AI2, I, ID, T, PadL, GV),!.



% Identify functions in predicate arguments
% Variables:
%	i1: position of argument in literal
%	i2: position of literal in clause
%	i3:	Clause ID
%	i4: list of arguments of predicate
%	i5: (g)round or (v)ariable based
function_arguments(_,_,_,[],_):-!.				% return result when done
function_arguments(AI,I,ID,[H|T],GV):-			% pick first argument on list
	var(H),										% if it is a variable
	AI2 is AI + 1,
	!,function_arguments(AI2,I,ID,T,GV).		%	go to the next
function_arguments(AI,I,ID,[H|T],GV):-			% otherwise
	atom(H),									% if it is a Prolog atom
	AI2 is AI + 1,
	!,function_arguments(AI2,I,ID,T,GV).		%	go to the next
function_arguments(AI,I,ID,[[_|[A|RA]]|T],GV):-	% otherwise it is a list, thus a function
	fa2([1], AI,I,ID,[A|RA],GV),				%	extract the function arguments of all functions in the literal
	AI2 is AI + 1,
	function_arguments(AI2,I,ID,T,GV).			% go to next predicate argument when done with current


% Extract arguments of functions and build index to clause literals
% Variables:
%	i1:	position vector of function argument in function
%	i2: position of argument in literal
%	i3: position of literal in clause
%	i4:	Clause ID
%	i5: list of arguments of function
%	i6: (g)round or (v)ariable based
fa2(_,_,_,_,[],_):-!.
fa2([PFAF|R], PAL, PLC, ID, [A|T], GV):-				% procedure very similar to clause_literals
	var(A),
	PFAF2 is PFAF + 1,
	!,fa2([PFAF2|R], PAL, PLC, ID, T, GV).
fa2([PFAF|R], PAL, PLC, ID, [A|T],GV):-
	atom(A),
	( \+f_arg(A, GV, _)
		->	increment(f_arg, FN)
	; f_arg(A, GV, FN)
	),
	asserta(f_arg(A, GV, FN)),
	asserta(fatc(FN, [PFAF|R], PAL, PLC, ID)),
	PFAF2 is PFAF + 1,
	!,fa2([PFAF2|R], PAL, PLC, ID, T, GV).
fa2([PFAF|R], PAL, PLC, ID, [[F|[A|RA]]|T], GV):-
	( \+f_arg([F|[A|RA]], GV, _)
		->	increment(f_arg, FN),
			asserta(f_arg([F|[A|RA]], GV, FN)),
			asserta(fatc(FN, [PFAF|R], PAL, PLC, ID)),
			fa2([1|[PFAF|R]], PAL, PLC, ID, [A|RA], GV)			% proceed with deeper level functions, if any
	; duplicate_term([F|[A|RA]],AD),
	  findall( X,
			   ( f_arg(AD, GV, X),
			     f_arg(Orig, GV, X),
				 Orig =@= [F|[A|RA]] ),
			   Xs),
	  ( Xs == []
		 ->	increment(f_arg, AN),
			asserta(f_arg([F|[A|RA]], GV, AN)),
			asserta(fatc(AN, [PFAF|R], PAL, PLC, ID)),
			fa2([1|[PFAF|R]], PAL, PLC, ID, [A|RA], GV)		% proceed with deeper level functions, if any
	  ; Xs = [AN]
		 -> asserta(fatc(AN, [PFAF|R], PAL, PLC, ID)),
			fa2([1|[PFAF|R]], PAL, PLC, ID, [A|RA], GV)			% proceed with deeper level functions, if any
	  )
	; true
	),
	PFAF2 is PFAF + 1,
	fa2([PFAF2|R], PAL, PLC, ID, T, GV).
fa2([PFAF|R], PAL, PLC, ID, [_|T], GV):-	
	PFAF2 is PFAF + 1,
	fa2([PFAF2|R], PAL, PLC, ID, T, GV).


%% Simplification

% --1: indicator on how to proceed with inferencing
simplify_clause_set(End):-
	( cl_stati(X, _) ; X = 0 )
	-> simplification_rotation(X, End), !.

% ++1: rotation start situation
% --2: indicator on how to proceed with inferencing
simplification_rotation(Start, End):-
	findall( X, 									% ...
			 (	clause(X, _, _, Cond),				% ...
				active_clause(Cond)
			 ),										% ...
			 SubS),									% ...
	writeln("Removing subsumed input clauses ..."), % remove redundant clauses
	maplist(remove_subsumed_clause, SubS, _),		% ...
	writeln("Factoring input clauses ..."),			% Factoring
	factor_input_clauses(SubS),						% ...
	writeln("Eliminating redundant literals from input clauses ..."),	% simplify input clauses
	rem_red_lit_from_input_clauses(End1),								% ...
	( integer(End1)
		-> true
	; ( cl_stati(X, _) ; X = 0 ),
	  ( Start == X
			-> End = End1
		; !, simplification_rotation(X, End)
	  )
	), !.


% Check whether clause is not eliminated
active_clause([]):-!.		% It isn't eliminated when empty list
active_clause(Cond):-		% It isn't eliminated when first element of the list == e
	nth1(1, Cond, Elem),
	Elem \== e, !.
	

rem_red_lit_from_input_clauses(Empty):-
	var(Empty),
	clause(C,_,Dis,Cond),								% BTP1: pick clause
	active_clause(Cond),								% but not an eliminated one
	c_dat(C, S, _, _, _),								% obtain in S the type (at this point only b or s))
	rem_red_lit(C,Dis,Cond,[],DisOut,[],Reason, NCon),	% remove redundant literals 
	DisOut \== Dis,										% if not, backtrack to BTP1
	eliminate_clause(C, Reason),						% otherwise eliminate the clause
	add_new_clause([DisOut, Reason, S, S, NCon], NCID),
	DisOut == [],
	!, Empty = NCID.													%	and backtrack to BTP1
rem_red_lit_from_input_clauses(_):-!.


% remove redundant literals
% Variables:
%	++1: clause ID
%	++2: list of disjunctions of the clause
%	++3: condition
%	++4: in-accumulator for retained literals
%	--5: out-accumulator for retained literals
%	++6: in-accumulator for causes of non-retentions
%	--7: out-accumulator for causes of non-retentions
%	--8: new condition
rem_red_lit(_,[],Cond,DisIn,DisOut,Reason,[red, Reason],Cond):-
	reverse(DisIn,DisOut),
	!.
rem_red_lit(C, [P1|RestDis], Cond, DisIn, DisOut, Rin, Rout, NCond):-					% remove duplicate literals
	nth1(_,RestDis,P2),
	P1==P2,
	!, rem_red_lit(C, RestDis, Cond, DisIn, DisOut, [[dup, P1]|Rin],Rout, NCond).
rem_red_lit(C,[[TF|Atom]|RestDis], Cond, DisIn, DisOut, Rin, Rout, OutC):-	% remove negated unit clause literals
	duplicate_term(Atom,AD),
	( TF==0 -> NTF = 1 ; NTF=0 ),		% create negation of fact truth in atc()-form
	c_atom(_,AD,AID,_,_,v),				% BTP1: find the ID of an atom that unifies with the input atom, using v-based weight
	c_atom(_,X,AID,_,_,v),				% retrieve the exact form
	subsumes_term(X, Atom),				% check the comparative atom subsumes the input one
	atc(AID, CS, _, NTF, _),			% BTP2: find a clause that uses the subsuming atom
	CS \== C,							%	... and that is not the input clause itself
	clause(CS, [1,_], _, T),			%	... and that is a unit clause
	active_clause(T),							%	... and not is eliminated
	append(T, Cond, NCond),
	sort(NCond, NConds),
	!, rem_red_lit(C, RestDis, NConds, DisIn, DisOut, [[nuc, C, CS]|Rin],Rout, OutC).
rem_red_lit(CIDO, [[-1,identical,A,B]|RestDis], Cond, DisIn, DisOut, Rin, Rout, NCond):-		% remove negated identities
	A == B,
	!, rem_red_lit(CIDO,RestDis, Cond, DisIn, DisOut, [[nid,A]|Rin],Rout,NCond).
rem_red_lit(CIDO,[[TF|Args]|RestDis], Cond, DisIn, DisOut,Rin,Rout,NCond):-
	!, rem_red_lit(CIDO,RestDis, Cond, [[TF|Args]|DisIn], DisOut, Rin, Rout, NCond).
% Debug addition as the above should never fail
rem_red_lit(C, [P1|RestDis], Cond, DisIn, DisOut, Rin, Rout, NCond):-	
	writeln(rem_red_lit(C, [P1|RestDis], Cond, DisIn, DisOut, Rin, Rout, NCond)),fail.



% Checks whether a clause is subsumed. Always succeeds.
% Variables:
%	?1: clause ID for which subsumption BY another clause is to be checked
%	o2:	'no' if not subsumed, the ID of a subsuming clause otherwise
clause_subsumed(C, S):-
	clause_subsumer_candidates(C, Cands),		% retrieve all clause subsumer candidates and relevant data
	clause_subsumer(Cands, S),!.					% find the first proven subsumer



% Checks whether one or more literals from one clause are jointly subsumed by literals from another clause
% Variables:
%	i1: nested list with literal subsumption data
% example: [[2,553,223,[6,6],[1,2]]
%			[2,553,501,[2,10],[1,2]]
%			[2,553,504,[1,10],[1,2]]
%			[3,553,231,[6,8,8],[1,2,3]]
%			[3,553,232,[6,8,8],[1,2,3]]
%			[5,553,68,[3,5,8,9,10],[1,1,2,3,3]]
%		   ]
%	o2:	'no' if no joined subsumption, the ID of the subsuming clause otherwise
clause_subsumer([],no).								% no joined subsumption when empty list (reached)
clause_subsumer([[L, C, S, Cpos, Spos]|_], S):-
	clause(C,_,CDis,_), duplicate_term(CDis,CDC),	% retrieve and duplicate the disjunctions of the clause with subsumed literals
	clause(S,_,SDis,_), duplicate_term(SDis,SDC),   % idem for the clause with subsuming literals
	numlist(1, L, Nth),								% create a list [1...L] with L being the number of subsumption pairs
	maplist(pick_nth1(Cpos,CDC), Nth, Ccomb),		% make one term from the individually subsumed literals
	maplist(pick_nth1(Spos,SDC), Nth, Scomb),		% make one term from the individually subsuming literals
	subsumes_term(Scomb, Ccomb),!.					% test the joined subsumption
clause_subsumer([_|Rest], S):-						%	if it fails, try with next candidate
	!,clause_subsumer(Rest, S).



% Variables:
%	++i1: list of integers, each integer providing an index to elements of i2
%	+i2:  list of terms
%	?i3:  integer indicating which element from i1 should be picked
%	-o4:  element picked from i2
pick_nth1(Ln, Lp, N, Picked):-
	nth1(N, Ln, Nth1),
	nth1(Nth1, Lp, Picked).
	

% Variables
%	++1: list of clause IDs
factor_input_clauses(CIDs):-
	counter(clause, Start),					% obtain current number of clauses
	maplist(c_factored,CIDs,_),				% factor all clauses in ++1
	counter(clause, End),					% obtain number of clauses after factoring
	End > Start,							% if there are more
	findall( CID,							%	... find all clause IDs
			 (	clause(CID,_,_,E),			%	... for clauses not eliminated
				active_clause(E),					%	...
				CID > Start					%	... created after the beginning of factoring
			 ),
			 NCIDs),						% 	store them in a new list of clause IDs
	!, factor_input_clauses(NCIDs).			% 	and factor those
factor_input_clauses(_):-!.					% otherwise, stop.



% Main inference loop
% Variable:
%	--1: termination type
main_inference(Out):-
	clause_limits([s, b], Limits),			% compute limit	values of current (b)ase and (s)et of support clauses
											%	to allow further derived clauses in set of support
	( Limits == [0,0,0,0,0,0]				% when no s- or b-clauses found
		-> Out = none,						%	stop inferencing %%? or include i-clauses??
		!
	; findall( [L, W, C], 						% obtain (L)ength - (W)eight - (C)lause ID triples ...
			   ( c_ord(W, C, g, _, _), 			%	... using (g)round variable weights
			     c_dat(C, s, P, N, _),			%	... for current (s)et of support
			     plus(P, N, L)					%	... computing (L)ength from number of (P)ositive literals and (N)egative literals
			   ),
			   WXs),
	  sort(WXs, WXS),								% sort de triples ascending on L-W-C
	  inf(WXS,i,Limits,Empty),					% derive new clauses within set of support maxima
	  ( Empty == 0,								% if all set of support clauses are processed and no inconsistency found
	    c_dat(_,i,_,_,_)							% ... and no clauses generated outside the limits
		->  writeln("Increase Limits"),
			trace,
			!, main_inference(Out)				% 	reprocess with new limits
 	  ; integer(Empty)							% otherwise return the ID of the empty clause
		->	Out = Empty
	  )
	),!.


%			c_ord/5,	%% multi-set representation of clause
						%	arg1=clause weight
						%	arg2=clause ID
						%	arg3=g(round clause based) or v(ariable based)
						%	arg4=multiset representation, sorted descending
						%	arg5=position of literals in order of arg4
%			c_dat/5,	%% various clause attributes for inference efficiency
						%	arg1=clause ID
						%	arg2=clause type
						%		b(ase)
						%		i(nference)
						%		t(rial attempt)
						%		e(liminated)
						%		s(et of support)
						%	arg3=number of positive literals
						%	arg4=number of negative literals
						%	arg5=recursion level of skolem function with highest recursive embedding in clause literal


% compute for all active clauses the maximum encountered values impacting clause weight
% Variables:
%	--1: (list) maximum values found
clause_limits(Types, MaxList):-
	findall( [WC, DC, RC, LC, PLC, NLC],		% collect for each clause 
			 ( clause(CID, [LC, DC], _, Con),	%	... clause length and argument depth
			   active_clause(Con),						%	... unless the clause is eliminated
			   c_dat(CID,Type,PLC, NLC, RC),	% 	... number of positive and negative literals and skolem depth
			   memberchk(Type, Types),
			   c_ord(WC, CID, g, _, _)			%	... and ground-based clause weight
			 ),
			 S),
	(	S \== []												% if the obtained list of sextets is not empty
			->	numlist(1,6,NumList),							% ... create table header
				maplist(max_column_value(S),NumList,MaxList),	% ... compute maximum for each column
				asserta(limits(MaxList))
	;	MaxList = [0,0,0,0,0,0]
	),!.



%% Not used anymore but perhaps required for something later
clause_stat_update(MaxList):-
	step(Step,[W,D,R,L,PL,NL]),					% retrieve current limits
	!,
	findall( [WC, DC, RC, LC, PLC, NLC],		% collect the six values for each clause 
			 ( clause(CID, [LC, DC], _, Con),
			   active_clause(Con),				%	... which is not eliminated
			   DC >= D,							%	... with an argument depth greater or equal than current limit
			   LC >= L,							%	... and number of literals not smaller than current limit
			   c_dat(CID,_,PLC,NLC,RC),			% 	... and idem for number of positive and negative literals and skolem depth
			   RC >= R,
			   PLC >= PL,
			   NLC >= NL,
			   c_ord(WC, CID, g, _, _),			%	... and idem for clause weight
			   WC >= W
			 ),
			 S),
	(	S \== []												% if the obtained list of sextets is not empty
			->	numlist(1,6,NumList),							% compute the new limits
				maplist(max_column_value(S),NumList,MaxList),
				Nstep is Step + 1,
				asserta(step(Nstep, MaxList))					% store them as new step
	;	true
	),!.


max_column_value(Table,ColNumber,Max):-
    maplist(nth1(ColNumber), Table, Column),
	max_list(Column, Max).


propagate_positive_unit_clauses(Empty):-
	( puc_start(PS)								% determine clause ID to start from
		-> true
	; PS = 0),
	findall( CID, ( c_dat(CID, s, 1, 0, _),		% collect all positive unit clauses with CID > start ID
					CID > PS ), PUCs),
	limits(Limits),								% retrieve current step/2 limits
	puc(PUCs, i, Limits, Empty),				% propagate
	counter(clause, CC),
	retractall(puc_start(_)),
	asserta(puc_start(CC)),!.


pup_resolution(_):-

	findall(CID, c_dat(CID, s, 1, 0, _) , PUCs),
	limits(Limits),
	maplist(slr(Limits, 0, i), PUCs, Xs),
	append(Xs, XsA),
	maplist(add_new_clause,XsA,NCs),!.
pup_resolution(_):-writeln("pup_resolution failed").



% Inference loop on ordered clauses
% Variables:
%	++1: list of ordered clause IDs each element of the form [L(ength), W(eight), CID]
inf([],_,_,0):-!.									% If the list is empty, output '0'
inf([[0,_,ID1]|_], _, _, ID1):-!.					% If the empty clause is found, output the ID of the empty clause
inf([[_,_,CID]|R], Where, Limits, Out):-			% If the clause is inactive 
	clause(CID, _, _, Cond),						
	\+active_clause(Cond),							
	!, inf(R, Where, Limits, Out).
inf([[1,_,CID]|R], Where, Limits, Out):-			% If the clause is a unit-clause 
	clause(CID, [1,_], [[0,identical,A,B]], _),		%	... with identity generation
	\+clause(_, [1,_], [[-1,identical,A,B]], _),	%	... and not contradictory 
	l_arg(WA,A,_,_,_,g),							% then determine which of the two identities has the highest ranking
	l_arg(WB,B,_,_,_,g),
	( WA > WB
		->	ToRepl = A,
			WithWhat = B
	; WB >= WA
		->	ToRepl = B,
			WithWhat = A
	),
	clauses_to_replace(ToRepl, ToDo),			% collect in ToDo the clauses in which an identity needs to be replaced
	maplist(replid(ToRepl, WithWhat, CID), ToDo),
	findall( [L, W, C], 						% obtain (L)ength - (W)eight - (C)lause ID triples ...
			 ( c_ord(W, C, g, _, _), 			%	... using (g)round variable weights
			   c_dat(C, s, P, N, _),			%	... for current (s)et of support
			   plus(P, N, L)					%	... computing (L)ength from number of (P)ositive literals and (N)egative literals
			 ),
			 WXs),
	sort(WXs, WXS),								% sort de triples ascending on L-W-C
	inf(WXS,i,Limits,Out),					% derive new clauses within set of support maxima
	!.
/* The bit below works fine, but using conditional clauses is not yet foolproof 
inf([[_,_,CID]|R], Where, Limits, Out):-			% If the clause has only, but at least, two positives
	clause(CID, _, Dis, Cond),						
	c_dat(CID, _, P, 0, _),
	P > 1,
	derive_conditionals(CID, P, Dis, Cond, NCs),
	inf_order_for(NCs, [], Orders),
	sort(Orders, SOrders),
	ord_union(SOrders, R, NewList),
	!, inf(NewList, Where, Limits, Out).
*/
inf([[_,_,CID]|R], Where, Limits, Out):-	
	clause(CID, _, Dis, _),
writeln(""),
write(CID),
write("   "),
write(Dis),
	c_factored(CID,CID2),
	CID2 \== CID,
	inf_order_for(CID2, [], Orders),
	sort(Orders, SOrders),
	ord_union(SOrders, R, NewList),
	write("  factored"),
	!, inf(NewList, Where, Limits, Out).
inf([[_,_,CID]|R], Where, Limits, Out):-	
	clause(CID, _, Dis, Cond),
	rem_red_lit(CID, Dis, Cond, [], DisOut, [], [red,Reason], NCond),		% remove redundant literals 
	( DisOut == []													% if an empty clause is obtained
	   -> eliminate_clause(CID, [red,Reason]),							% 	eliminate the orginal clause
		  add_new_clause([[], [r_red, CID, Reason], s, i, NCond], RedC),			%	create the empty clause
		  !, inf([[0,0,RedC]], Where, Limits, Out)					% 	replace the set of support list with just the empty clause
	; DisOut \== Dis												% if the derived clause is different from the original one
	   -> eliminate_clause(CID, Reason),							% 	eliminate the original clause
		  add_new_clause([DisOut, [r_red, CID, Reason], s, i, NCond], RedC),		%	add the new one
		  inf_order_for(RedC, [], Order),							%	determine whether it should go on the s list
		  ord_add_element(R, Order, NewList),						%	if so, put it on it in the correct order
		  !, inf(NewList, Where, Limits, Out) 
	; remove_subsumed_clause(CID, SuBs),						% check whether the clause is subsumed
	  ( SuBs \== no												% if it is, then SuBs contains the subsuming clause ID
		 ->	c_ord(Wsub, SuBs, g, _, _), 						%	
			retract(c_dat(SuBs, _, PLsub, NLsub, DepthSub)),
			asserta(c_dat(SuBs, s, PLsub, NLsub, DepthSub)),
			plus(PLsub, NLsub, Lsub),
			ord_add_element(R, [Lsub, Wsub, SuBs], NewList),
			!, inf(NewList, Where, Limits, Out)
		  ; slr(Limits, 0, i, CID, Xs),
			maplist(add_new_clause,Xs,NCs),
			inf_order_for(NCs, [], Orders),
			sort(Orders, SOrders),
			ord_union(SOrders, R, NewList),
			!, inf(NewList, Where, Limits, Out)
		)
	).
inf([[_,_,_]|R], Where, Limits, Out):-trace,
	!, inf(R, Where, Limits, Out).


inf_order_for([], In, In):-!.
inf_order_for([CID|R], In, Out):-
	c_ord(W, CID, g, _, _), 
	c_dat(CID, s, PL, NL, _),
	plus(PL, NL, L),
	!,inf_order_for(R, [[L, W, CID]|In], Out).
inf_order_for([_|R], In, Out):-					% case when CID is outside the limit bounds and arg2 of c_dat \== s
	!,inf_order_for(R, In, Out).
	


% Find all clauses in which an atom needs to be replaced
% Variables:
%	+1: atom to replace
%	-2: list of clause IDs
clauses_to_replace(ToReplace, CIDs):-
	findall( CID,
			 (	c_dat(CID,s,_,_,_),								% restrict to s(upport)
				( 
					l_arg(_, ToReplace, LitArgID, _, _, g),		% find the atom to replace as predicate argument
					latc( LitArgID, CID, _, _)
				; 
					f_arg(ToReplace, g, FuncArgID),				% and as argument in skolem function
					fatc(FuncArgID, _, _, _, CID)
				)
			 ),
			 CIDC),
	sort(CIDC,CIDs),									% remove doubles
	!.


replid(ToRepl, WithWhat, IdCID, ToDo):-
	clause(ToDo, _, Dis, Cond),
	replace(Dis, DisO, ToRepl, WithWhat),
	replace(Cond, CondO, ToRepl, WithWhat),
	eliminate_clause(ToDo, [idr, IdCID, ToRepl, WithWhat]),
	\+clause(_,_,DisO,CondO),
	\+tautology(DisO,_),
	add_new_clause([DisO, [idr, ToDo, IdCID, ToRepl, WithWhat], s, s, CondO], _),
	!.
replid(_, _, _, _):-!.

/* not used yet
% Variables:
%	++1: Clause Id
%	++2: Clause's length
%	++3: Clause's disjunction list
%	++4: Clause's conditionals
%	--5: list with CIDs of conditional clauses generated
derive_conditionals(CID, L, Dis, Cond, NCIDs):-trace,
	numlist(1, L, NL),
	duplicate_term([Dis, Cond], [DisD, CondD]),
	findall([Pos, Lit], pick_nth1(NL, DisD, Pos, Lit), Picks),
	maplist(crea_con(CID, DisD, CondD), Picks, NCIDs),
	!.


crea_con(CID, Dis, Cond, [Pos, Lit], NCID):-
	nth1(Pos, Dis, Lit, Rest),
	append([Cond, Rest], NCond),
	sort(NCond, NConds),
	add_new_clause([[Lit], [split, CID, NConds], s, i, NConds], NCID),!.		%	add the new one
	
	

% Invert the truth of a literal
%	++1: literal
%	--2: negated literal
negated_literal([0|R],[-1|R]):-!.
negated_literal([-1|R],[0|R]):-!.
*/

inf_simplified(CID, Dis, Cond, Where, Limits, NCID):-
	inf_simplify(CID, Dis, Cond, Where, Limits, NCID),
	CID \== NCID,!.


% Simplify clause on set of support stack
% Variables:
%	++1: clause ID
%	++2: list of disjunctions of the clause to simplify
%	++3: truth condition (arg4 of clause/4)
%	++4: clause set in which to put the simplified clause 
%	++5: limits list to decide on ++4
%	--6:	ID of simplified clause (=++1 when no simplification achieved)
%inf_simplify(CID, Dis, Cond, Where, Limits, NCID)
inf_simplify(CID,[[0,identical,I1,I2]],CIDout,Where):-		% positive identity unit clause
	writeln(CID),
	I2 \== I1,
	identity(_,I1,IN),										% I1 is already determined as carrying priority
	inactivate_clause(CID, [idp, IN]),
	create_conclusion_clause(-1, [[0,identical,I1,I2]], [id,CID,IN], i, Where, _, CIDout),
	asserta_once(identity(I2, I1, CIDout)),
	replace_identities(I2,I1,[idr,CIDout,IN]),!.
inf_simplify(CID,[[0,identical,I1,I2]],CIDout,Where):-		% positive identity unit clause
	I2 \== I1,
	identity(_,I2,IN),
	inactivate_clause(CID, [idp, IN]),
	create_conclusion_clause(-1, [[0,identical,I1,I2]], [id,CID,IN], i, Where, _, CIDout),
	asserta_once(identity(I1, I2, CIDout)),
	replace_identities(I1,I2,[idr,CIDout,IN]),!.
inf_simplify(CID,[[0,identical,I1,I2]],CIDout,Where):-		% positive identity unit clause
	identity(I1,I3,IN),
	I2 \== I3,
	inactivate_clause(CID, [idp, IN]),
	create_conclusion_clause(-1, [[0,identical,I1,I2]], [id,CID,IN], i, Where, _, CIDout),
	asserta_once(identity(I2, I3, CIDout)),
	replace_identities(I2,I3,[idr,CIDout,IN]),!.
inf_simplify(CID,[[0,identical,I1,I2]],CIDout,Where):-		% positive identity unit clause
	identity(I2,I3,IN),
	I1 \== I3,
	inactivate_clause(CID, [idp, IN]),
	create_conclusion_clause(-1, [[0,identical,I1,I2]], [id,CID,IN], i, Where, _, CIDout),
	asserta_once(identity(I1, I3, CIDout)),
	replace_identities(I1,I3,[idr,CIDout,IN]),!.
inf_simplify(CID,[[0,identical,I1,I2]],CID,Where):-			% positive identity unit clause
	I2 \== I1,
	retract(clause(CID,_,_,_)),								% move it to Where
	asserta_once(clause(CID,1,[[0,identical,I1,I2]],Where)),
	identity_priority([0|[identical,I1,I2]],CID,P),
	(	P == 1
			->	replace_identities(I2,I1,[idr,CID,CID])
	;	replace_identities(I1,I2,[idr,CID,CID])
	),!.
inf_simplify(CID,DisIn,CIDout,Where):-
	rem_red_lit(CID,DisIn,[],DisOut,[],Rout),					% remove redundant literals
	(	DisOut == []											% if empty clause: inconsistency
			->	CIDout = 0,
				inactivate_clause(CID, Rout),
				create_conclusion_clause(-1, [], Rout, i, u, _, ClauseID),
				asserta(stopped([inc, ClauseID])) 
	;	DisOut == DisIn											% no simplification achieved
			->	retract(clause(CID,L,_,Set)),						% move it to Where
				asserta_once(clause(CID,L,DisIn,Where)),
				CIDneg is 0 - CID,
				( Where == p
					->	retract(pas(PAS)),
						clausedat(CID, _,_,_,_,_,PO),
						ord_add_element(PAS,[PO,CIDneg],NPAS),
						asserta(pas(NPAS))
				; Set == p,
				  pas(PAS),
				  member([MD,CIDneg],PAS)
					->	retract(pas(PAS)),
						ord_del_element(PAS,[MD,CIDneg],NPAS),
						asserta(pas(NPAS))
				; true
				),
				CIDout = CID
	; 	inactivate_clause(CID, Rout),
		create_conclusion_clause(-1, DisOut, Rout, i, Where, _, CIDout)
	),
	!.




% Positive unit clause propagation
% Variables:
%	++1: list of clause IDs to process
%	++2: destination type of infered clauses when within thresholds
%	++3: limits
%	--4: either 0 or ID of an empty clause
puc([],_,_,0):-!.	
puc([ID1|_], _, _, ID1):-
	clause(ID1, [0,_], [[]], []),!.								% when empty clause in generated list
puc([ID1|T], Where, [MaxW, MaxD, MaxFR,MaxL,MaxNP,MaxNN],Out):-
	clause(ID1, [1,CD1], [[0|[P|A1]]], D1),						% retrieve the clause
	c_ord(W1, ID1, g, _, _),									% ... with WT-based weight type 
	c_dat(ID1, From, _, _, FR1),									% retrieve where stored
	CD1 =< MaxD,
	W1 =< MaxW,
	FR1 =< MaxFR,
	findall( [ [X], [puc, ID1, ID2], From, Where, D3],
			 (	clause(ID2, [2,CD2], [[-1|[P|A2]], [TF3|A3]], D2), % BTP1: find a n(1)-p/n(1) clause with n(1) predicate as ID1
				active_clause(D2),								%	which is not eliminated
				c_dat(ID2,_,_,_,CFR2),							%	without a recursed skolem function outside limit
				CFR2 =< MaxFR,
				CD2 =< MaxD,
				\+cl_stata(_,[pup, ID1, ID2]),					% BTP2: require that no clause has already been generated by BTP1 and BTP2
				_ = [ [P|A1], [P|A2], A3, D1, D2 ],				% create a dummy term for BTP2-clause wide resolution
				unify_with_occurs_check([P|A1], [P|A2]),		% BTP3: check whether safe unification is possible
				X = [TF3|A3],										% if so, generate the resolvent positive literal
				\+clause(_,[1,_],[X],_),						% BTP4: check that such unit clause does not already exist
				append(D1, D2, D3)								% combine the raa conditionals
			 ),
			 Xs),												% all satisfying generated literals with their parent clauses ID
	sort(Xs, Xss),												% sort the result set
	( Xss \== []
		-> puc_result_cleaned(Xss, [], Xcl),					% remove double literals
		   maplist(add_new_clause, Xcl, Added),					% generate the resolvents as new positive unit clauses
		   append(Added, T, NewIn)
	; Xss == []
		-> NewIn = T
	),
	!,puc(NewIn, Where, [MaxW, MaxD, MaxFR,MaxL,MaxNP,MaxNN],Out).	% if so, start new cycle
puc([_|T], Where, Limits, Out):-				% don't further process generated clauses outside the limits
	!, puc(T, Where, Limits, Out).


puc_result_cleaned([X], In, [X|In]):-!.
puc_result_cleaned([ [ [X], _, _, _, D1] | [[ [Y], R, F, W, D2] | T]], In, Out):-
	X == Y,
	D1 == D2,
	!, puc_result_cleaned([ [ [Y], R, F, W, D2] | T], In, Out).
puc_result_cleaned([ [ [X], RX, FX, WX , D1] | [[ [Y], RY, FY, WY, D2] | T]], In, Out):-
	X \== Y,
	!, puc_result_cleaned([ [ [Y], RY, FY, WY, D2] | T], [[ [X], RX, FX, WX, D1 ] | In], Out).



store_process_results([Dis, R], NCID):-
	add_new_clause([Dis, R, i], NCID).



% Single non-identity-literal resolution
% Variables:
%	+1: restriction list for 2nd clause [weight, depth max, skolem recursion level max, length max, poslit max, neglit max]
%	+2: starting clause number for 2nd clause
%	+3: destination type
%	+4: selected clause for resolution
%	o5:	resolvent clauses
slr(Limits, SCN, Where, CA1, XsF):-
	findall( [ R12S, [slr, C, P, CA1, A1P], From, Where, S3], % collect resolvent, clause, and literal position of unifying literal
			 resolvent(Limits, SCN, Where, CAI, [ R12S, [slr, C, P, CA1, A1P], From, Where, S3]),
			 Resolvents),
	sort(Resolvents, Xs),
	( member([[[0,identical,LeftI,RightI]]|ResData], Xs)	% If identity discovered, retain only the identity
		-> XsS = [[[[0,identical,LeftI,RightI]]|ResData]]
	; XsS = Xs
	),
	free_from_similar_dis(XsS, [], XsF).							% remove =@= disjunctions from list



% Variables:
%	+1: restriction list for 2nd clause [weight, depth max, skolem recursion level max, length max, poslit max, neglit max]
%	+2: starting clause number for 2nd clause
%	+3: destination type
%	+4: selected clause for resolution
%	o5:	resolvent clause data
resolvent(Limits, SCN, Where, CAI, [ R12S, [slr, C, P, CA1, A1P], From, Where, S3S]):-
	atc(AI, CA1, A1P, TF, 0),				% retrieve atom unique ID (AI) and truth value (TF) for a non-identity literal of CA1
	(TF == 0, NTF = 1; TF == 1, NTF = 0),	% produce in NTF the opposite truth value
	c_atom(_, A, AI, _, _, v),				% retrieve the atom (A) in the variable-based atom index
	c_dat(CA1, From, _,_,_),
	duplicate_term(A, AD),					% duplicate A in AD for further processing
	c_atom(_, AD, XI, _, _, v),				% BPT1: pick an atom that unifies with AD
	atc(XI, C, P, NTF, _),					% BPT2: pick a clause in which the unifying literal exist with opposite TF
	CA1 \== C,								% it may not be the base clause
	clause(CA1,_,D1,S1), 					% retrieve the base clause's disjunction list and status
	active_clause(S1),						% the clause may not have been (e)liminated
	( Limits == []
	   ->	clause(C,_,D2,S2),				% pick clause
			C > SCN							%	if clause number is greater than minimum
	; Limits \== []
	   ->	Limits = [C2WM, C2DM, C2FRM, C2LM, C2PLM, C2NLM],
			clause(C,[C2L, C2D],D2,S2), 		% picked resolution candidate must have 
			c_ord(C2W, C, v, _, _),			%
			C > SCN,							%	... clause number greater than minimum
			C2W =< C2WM,						%	... weight not larger than weight max
			C2L =< C2LM,						%	... length not longer than requested
			C2D =< C2DM,						%	... depth not ...
			c_dat(C, _, C2PL, C2NL, C2FR),		% and also ...
			C2PL =< C2PLM,						%	... not larger number of positive literals
			C2NL =< C2NLM,						%	... not larger number of negative literals
			C2FR =< C2FRM						%	... not larger recursion level depth
	),
	active_clause(S2),									%	... not been eliminated
	duplicate_term([D1,S1], [D1D, S1D]),
	duplicate_term([D2,S2], [D2D, S2D]),
	nth1(A1P, D1D,[TFC|U1],R1),				% retrieve in R1 the literals of the base clause without the unifying one
	nth1(P, D2D, [NTFC|U2],R2),				% BPT3: find a possible unifier and (R)est-literals in the candidate clause
	_ = [[[TFC|U1]|R1],S1D,[[NTFC|U2]|R2],S2D],
	unify_with_occurs_check(U1,U2),			% attempt unification, and when successful:
	append(R1,R2,R12),						% combine the rest-literals from the two clauses
	append(S1D, S2D, S3),
	sort(R12,R12S),							% sort the combination
	sort(S3, S3S),
	pre_clause_add_check(R12S).				% check for redundancy


% If the ++1 list contains members which of which the resolvents are =@= variants of each other, keep the last such variant
% Variables:
%	++1: input list
%	++2: accumulator
%	--3: ++1 without redundant variants 
free_from_similar_dis([],In, In):-!.
free_from_similar_dis([[H|_]|T],In, Out):-
	member([X|_], T),
	H =@= X,
	!, free_from_similar_dis(T, In, Out).
free_from_similar_dis([H|T],In, Out):-
	!, free_from_similar_dis(T, [H|In], Out).



% Checks non-redundancy of derived disjunction list
% Variable:
%	i1: disjunction list 
pre_clause_add_check(D):-		%% improve??
	\+clause(_,_,D,_),					% reject when the combination exists already as clause
	\+part_redundant(D,[],_),			% also when it is subsumed by another existing clause
	length(D, LD),						% obtain the length
	\+internally_redundant(_,LD,D,_),	% reject the combination when otherwise redundant
	\+externally_redundant(D,_),!.



% Collect in SUBS all sublists of length N that can be formed by members of L in any order, using duplicates in L only once
% Variables:
%	++1:	integer specifying the length of the desired sublists
%	+2:		the list to create sublists from. %% USE ONLY FOR SHORT LISTS.
%	-o3:	all possible sublists
sublists(N,L,SUBS):-
	findall( X, 
			 ( permutation(L, P),	% This is factorial with list length! 
			   same_order_sublist(N, P, X)
			   ),
			 Xs),
	sort(Xs, SUBS),!.
same_order_sublist(N,L,SUB):-
	length(SUB,N),
	append([_,SUB,_],L).



% collects for a clause C all clauses S of equal or smaller length such that each literal in S individually subsumes
% 	some literal from C  %% Proceeds only on unconditional clauses
% This can be used as a precursor to find amongst S at least one clause that subsumes C, and hence makes C redundant in the 
%	clause set.  
% FAILS: when there are no subsumer_candidates
% Variables:
%	?1: ID of clause for which potential clause subsumers are to be found
%	o2: a list1 of tuples [N, C, CS, CP, CSP], indexed on N which is the length of each of the lists CP and CSP, where:
%			C is the ID of the clause used a input of first argument and CS the ID of a clause potentially subsuming C
%		 	CP and CSP hold the positions of the literals in C, resp. CS, that should be tested for subsumption together
% example: [[2,553,223,[6,6],[1,2]]
%			[2,553,501,[2,10],[1,2]]
%			[2,553,504,[1,10],[1,2]]
%			[3,553,231,[6,8,8],[1,2,3]]
%			[3,553,232,[6,8,8],[1,2,3]]
%			[5,553,68,[3,5,8,9,10],[1,1,2,3,3]]
%		   ]
clause_subsumer_candidates(C, Out):-
	clause(C,[L,_],Dis,[]),
% example: 	clause(1286,_,C,_).
%		   	C = [[-1, 'instance-of', _A, human, _B], [0, 'instance-of', _A, _, _B], [0, 'occurs-in', a, a]].
	maplist(literal_matchers(C, sbb), Dis, LMs),
%			LMs = [[[[3,0,1],1286],[[[2,0,1],72],[[2,0,1],73],[[2,0,1],74],[[2,2,1],1285],[[3,0,1],68],[[3,0,1],498],
%									[[4,0,1],84],[[4,0,1],86],[[4,0,1],451],[[4,0,1],452],[[4,0,1],663],[[4,0,1],664],
%									[[4,0,2],451],[[4,0,2],663]]],
%				   [[[3,0,2],1286],[[[3,0,3],68],[[4,0,4],452],[[4,0,4],664]]],
%				   [[[3,0,3],1286],[[[1,0,1],1281],[[2,0,1],1284],[[2,0,2],1284],[[3,0,3],274],[[4,1,4],289],
%									[[4,1,4],290],[[4,1,4],330],[[4,1,4],333],[[5,1,5],288]]]]
	maplist(nth1(2), LMs, Matchers),
	append(Matchers, ApM),
%			ApM = [[[2,0,1], 72],[[2,0,1], 73],[[2,0,1], 74],[[2,2,1],1285], [[3,0,1],  68],[[3,0,1], 498],[[4,0,1], 84],
%				   [[4,0,1], 86],[[4,0,1],451],[[4,0,1],452],[[4,0,1], 663], [[4,0,1], 664],[[4,0,2], 451],[[4,0,2],663],
%				   [[3,0,3], 68],[[4,0,4],452],[[4,0,4],664],[[1,0,1], 1281],[[2,0,1],1284],[[2,0,2],1284],[[3,0,3],274],
%				   [[4,1,4],289],[[4,1,4],290],[[4,1,4],330],[[4,1,4], 333], [[5,1,5],288]]
	sort(1,@=<, ApM,ApM1),
	sort(2,@=<, ApM1,ApM2),
	findall(X, member([_,X], ApM2), Xs),
%		   Xs = [68,68,72,73,74,84,86,274,288,289,290,330,333,451,451,452,452,498,663,663,664,664,1281,1284,1284,1285]
	sort(Xs, Xss),
%		  Xss = [68,72,73,74,84,86,274,288,289,290,330,333,451,452,498,663,664,1281,1284,1285]
	include(subsumer_clause_filter1(ApM2, L), Xss, Cc),
%		  Cc = [1281,1284]
	findall( [[C,CX],[Q, B]],						% out-structure in this format ensured that when there is more than
			 ( member([[[_,_,CX], C], Y], LMs),		%	one candidate subsumer clause, the literals of each clause
			   member([[_,_,B], Q], Y),				%	are grouped together in the set.
			   member(Q, Cc) ),
			 Out1 ),
	sort(Out1, Out2),
%		  Out2 = [[[1286, 3], [1281, 1]], 			% there may be more than one candidate subsumer clause (here 1281 and 1284)
%				  [[1286, 3], [1284, 1]], 			% one literal may be subsumed by more than subsuming literal
%				  [[1286, 3], [1284, 2]]].
% Other example: Out2 = [[[6111, 2], [611, 1]], 
%						 [[6111, 3], [611, 2]]].
	maplist(subsumer_clause_data(Out2, C), Cc, Out3),
	sort(Out3, Out).



	

% Filter condition 
% Variables:
%	++1: a list of pairs [[DL, LD, PL], C], where DL is the number of disjunctions in the clause with clause identifier C,
%		 LD the depth of the clause and PL the position of a literal in the clause that was selected for some reason
%	++2: the clause ID to which the filter condition is tested
subsumer_clause_filter1(Matchers, LC, C):-
	findall(L, ( member([L,C], Matchers), 
				 L = [LL,_,_],					% candidate subsumers may not be larger than the clause compared with
				 LL =< LC ), 
			Ls),								% collect in Ls the first arguments of the pairs that have C as 2nd arg.  
	sort(Ls, [[DL,_,_]|Lss]),					% remove doubles from Ls resulting in Lss
	length([[DL,_,_]|Lss], DL).					% return 'true' when the length of Lss is equal to DL


% Reorganize the subsuming literals data structure
% Variables:
%	?1: a list of pairs, each such pair being composed of two pairs as well
%	?2: the ID of the clause with subsumed literals
%	?3: the ID of the clause with subsuming literals
%	o4: a quintuple with restructured info
subsumer_clause_data(M, S, C, [LMs, S, C, Bs, Ds]):-
	findall( B,
			 member([[_, B], [C, _]], M),
			 Bs),								% aggregate the positions of the subsumed literals from S
	findall( D,
			 member([_, [C, D]], M),
			 Ds),								% aggregate the positions of the subsuming literals from C 
	length(Bs, LMs).							% determine the length of the subsumed literals



% collects for a given literal L from clause C, all clauses D distinct from C that have a literal that matches L in manner M
% uses c_atoms constructed with variable-based weighting
% Variable:
%	?1: the clause ID
%	++2: matching manner (see gen_spec() )
%	+i3: literal in standard data structure format
%	o4: output: pair [L-data, [D1-data, D2-data, ...]] where
%			L-data ::= [[L,LD,PL],C] where
%							L: number of literals in clause with ID C
%							LD: depth of the clause (embedded functions)
%							PL: position of matching literal L in C1
%							C: clause ID
%			Dn-data: same format as L-data but for each matching clause Dn found
literal_matchers(C, M, [TF|Atom], Out):-
	(TF == -1 -> STF = 1 ; STF = 0),					% convert -1 to 1 to accomodate atc()-representation	
	atc(AID, C, PLC, STF, _),							% BTP1: pick an atom ID with given TF present in clause C
	c_atom(_,Atom,AID,_,_,v),							% check the atom unifies with the input atom, using v-based weight
	clause(C, [LC,LDC], _, _),							% retrieve the length and clause depth of C
	findall( [[L,LD,PL],CID,[STF|Atom]],				% create the return data structures for the following criteria
			 ( c_atom(_,Atom,X,_,_,v), 					% find all atom IDs that have a unifying atom with the input atom
			   atc(X, CID, PL, STF, _),					% find for these the clause IDs of clauses with unifying input literal
			   CID \== C,								% excluding the input clause itself
			   clause(CID, [L,LD], _, T),				% and excluding eliminated clauses
			   active_clause(T) ),
			 Rs),
	duplicate_term([[LC,LDC,PLC],C,[STF|Atom]], D),
	gen_spec(Rs, [D], M, [], [Out]),!.					% select from the data structure set those that match in the given way


% collects for all argument structures R of a given predicate P all atoms S that match R in manner M
% Variable:
%	i1: 	predicate name
%	++2:	matching manner (see gen_spec() )
%	o3:		nested output list of following structure S:
%				S 	::= [LA, NEL] where:
%							LA: left atom of the tuple 'LA matches ...'
%							NEL: ascending list of pairs
%				NEL ::=	[ [WA1, RA1], [WA2, RA2], [WA3, RA3], ... , [WAn, RAn] ], where:
%							WAn: weight of the atom RAn that matches with LA 
pred_arg_matchers(P, M, Out):-
	findall([W,X,R], c_atom(W,[P|R],X,_,_,v), Rs),
	duplicate_term(Rs, D), 
	gen_spec(D, Rs, M, [], Out),!.



% collect for each data structure R in a list L all data structures R' that match R in manner M 
% Variables:
%	i1:	fixed list of data structures, each element of the form [X,Y,Z], where:
%			Z: some data structure comparable to the Z' of any other member
%			Y: a unique ID for the data structure DS from which Z is retrieved
%			X: a term taken or computed on the basis of parts of DS
%	i2: same list but recursively traversed from beginning to end.
%		at call-time, must be a duplication of i1 created using duplicate_term 
%	i3: way in which 'matching' should be interpreted, options:
%			uni: unifiable
%			sbb: subsumed by
%			sbd: subsumed by but distinct, i.e. two sides are not Prolog identical
%			sub: subsumes
%			sud: subsumes but distinct
%	i4: in-accumulator for subsumers
%	o5: out-accumulator
gen_spec(_, [], _, In, In):-
%	maplist(writeln, In),
	!.
gen_spec(D, [[WX,I1,X]|T], M, In, Out):-
	findall( [W, I2], 
			 ( member([W,I2,Y], D),
			   ( M == uni
				  -> unify_with_occurs_check(X, Y)
			   ; M == sbb
				  -> subsumes_term(Y, X)			
			   ; M == sbd
				  -> subsumes_term(Y, X),			
					 I1 \== I2
			   ; M == sub
				  -> subsumes_term(X, Y)			
			   ; M == sud
				  -> subsumes_term(X, Y),			
					 I1 \== I2
			   )
			 ),
			 Ss),
	( Ss == []
		-> gen_spec(D, T, M, In, Out)
	; sort(Ss, O),
	  gen_spec(D, T, M, [[[WX,I1],O]|In], Out)
	),!.



%%%%%%%%%%%%%%%%%%%%%%%%
%% Clause elimination %%
%%%%%%%%%%%%%%%%%%%%%%%%


%% First reductions of input clause set for optimization
obsolete_clauses:-								% find clauses with positive literals never used negatively elsewhere	
	opp(_, P, _, 0),
	findall(C, 
			( posax(C, _, _, Dis),
			  member([0|[P|_]], Dis)
			  ),
			Cs),
	obscl(Cs),
	fail.
obsolete_clauses:-								% identify terminological inverse relation definitions
	posax(X1,_,Axiom,Dis1),						% BPT1: pick an input clause of length 2
	length(Dis1, 2),
	posax(X2,_,Axiom,Dis2),						% BPT2: pich another one of length 2 from the same axiom
	length(Dis2, 2),
	X2 \== X1,									% must really be a different one
	duplicate_term(Dis1,DisX1),
	DisX1 = [[-1|[P|Args11]],[0|[Q|Args12]]],	% ensure the clause has the appropriate structure
	P \== Q,									% the predicate names in each literal must be different
	\+inv(_,[P|_],_),\+inv(_,[Q|_],_),			% do what follows only once per retained clause pair
	term_variables(DisX1,Vars),					% ground the variables in the first clause
	maplist(term_to_atom, Vars, Atoms),
	replace(DisX1,DisX1O,Vars,Atoms),
	DisX1O = [[-1|[P|Args11]],[0|[Q|Args12]]],	
	duplicate_term(Dis2,DisX2),
	DisX2 = [[-1|[Q|Args12]],[0|[P|Args11]]],	% unify the instantiated clause with the second one
	opp(_,P,PN,_),								% retrieve the occurrences of the predicate names
	opp(_,Q,QN,_),
	Dis1 = [[-1|[P|ArgsP]],[0|[Q|ArgsN]]],		% unify the orginal first clause with the pattern
	( PN >= QN									% store the inverse predicate structures, the one to be switched out as arg2
		-> asserta_once(inv(Axiom,[Q|ArgsN],[P|ArgsP]))
	; asserta_once(inv(Axiom,[P|ArgsP],[Q|ArgsN]))
	),
	fail.										% backtrack to BPT1 until all clauses processed
obsolete_clauses:-!.


obscl([]):-!.
obscl([C|T]):-
	asserta(no_inf(C)),
	!, obscl(T).


% Variables:
%	i1: clause ID
%	o2: 'no' if not subsumed, the ID of a subsuming clause otherwise
remove_subsumed_clause(CID, S):-
	clause_subsumed(CID, S),
	(	S \== no									
			-> eliminate_clause(CID, [subsumed_by, S])
	;	S == no
			-> true
	).
remove_subsumed_clause(_, no).			% when clause_subsumed failed, return no subsuming clause


	
%% individual clause removal routines

eliminate_clause(C, Reason):-
	retract(clause(C,B,Dis,Cond)),
	asserta(clause(C,B,Dis,[e,Cond])),
	retract(c_dat(C, _, P, L, R)),
	asserta(c_dat(C, e, P, L, R)),
	asserta(cl_stati(C, Reason)),
	retractall(atc(_,C,_,_,_)),
	retractall(latc(_,C,_,_)),
	retractall(fatc(_,_,_,_,C)),
	retractall(c_ord(_,C,_,_,_)),
	!.
eliminate_clause(C, Reason):-
	writeln([eliminate_clause, C, Reason]),trace,!.




rec_level(List, ListDepth, RecLevel):-
	ground_clause(List,GList),
	findall([Y|T],(T\==[],memberNestList([Y|T],GList)),Xs),
	maplist(rl2,Xs,Y),
	max_list(Y,Rmax),
	(	Rmax < ListDepth
		 -> RecLevel = Rmax
	;	RecLevel = ListDepth
	),!.


rl2([A|Args],RL):-
	flatten([A|Args],F),
	findall(A,member(A,F),As),
	length(As,RL).





% Determine whether there is exactly one unary function used in the input set of axioms and data
% Variable:
%	i1:	constant type order
single_unary_function(Order):-
	nth1(N, Order, fuf),				% retrieve the place of 'fuf' in that order
	findall(X, fp(1,_,_,X,_), Xs),		% if there is a single unary function in the input axioms and data
	(	length(Xs, 1)
			->	asserta(fuf([X,N], N))		% store it with its rank order
	;	true
	),!.


% Variables:
%	i1: argument list of some predicate
%	i2: name of ordering predicate 
%	i3: substitution for variables
%	i4:	in-argument of difference list
%	o5:	out-argument of difference list 
numbered_ms([],_,_,In,Out):-
	reverse(In, Out),!.
numbered_ms([H|T],Order,S,In,Out):-				% give variables weight 0
	var(H),
	!,numbered_ms(T,Order,S,[S|In],Out).
numbered_ms([[H|A]|T],Order,S,In,Out):-			% recursively create the number representation for function arguments
	is_list(H),
	numbered_ms(H,Order,S,[],OutN),
	numbered_ms(A,Order,S,OutN,OutN2),
	!,numbered_ms(T,Order,S,[OutN2|In],Out).
numbered_ms([[H|A]|T],Order,S,In,Out):-			% replace function names
	Term =.. [Order, H, f, Value],
	call(Term),
	numbered_ms(A,Order,S,[Value],OutN),
	!,numbered_ms(T,Order,S,[OutN|In],Out).
numbered_ms([H|T],Order,S,In,Out):-				% replace atomized variables
	Term =.. [Order, H, v, Value],
	call(Term),
	!,numbered_ms(T,Order,S,[Value|In],Out).
numbered_ms([H|T],Order,S,In,Out):-				% replace constants
	Term =.. [Order, H, c, Value],
	call(Term),
	!,numbered_ms(T,Order,S,[Value|In],Out).
numbered_ms([H|T],Order,S,In,Out):-				% replace predicate names
	Term =.. [Order, H, p, Value],
	call(Term),
	!,numbered_ms(T,Order,S,[Value|In],Out).
numbered_ms([H|T],Order,S,In,Out):-				% replace 'identical'
	Term =.. [Order, H, i, Value],
	call(Term),
	!,numbered_ms(T,Order,S,[Value|In],Out).
	

%	Return for each level of sublists the greatest number, in ascending order of list depth,
%	ignoring the first element of each (sub)list
%		Example: max_arg_elems([5,2,[300,9,11,[500,8,9],24],[400, 15],2],[],L).
%		returns: [2, 24, 9]
% Variables
%	i1:	list whose lements are numbers and/or lists with numbers and/or ...
%	i2:	in-accumulator
%	o3: out-accumulator
max_arg_elems([_|Args],In,Out):-
	mixed_list_max_number(Args,Max),				% return in Max the greatest number in the list, ignoring members being lists
	list_depth(Args,AD),							% compute the list depth
	( AD > 1										% if there are sublists
		-> findall([_|U], member([_|U],Args), X),	%	collect all sublists without their first element
		   append(X,XA),
		   max_arg_elems(XA,[Max|In],Out)			%	process them recursively
	; reverse([Max|In], Out)						% put in ascending order of depth found
	),!.
	



% Compute which of two nested multisets over positive integers is the greatest
% Variables:
%	i1:	first nested multiset to compare
%	o2: result as the atoms (<), (>) (=) depending on whether i1 is smaller/greater/equal to i3
%	i3: 2nd list
nms_compare(L1,Comp,L2):-
	atom(L1), atom(L2),
	compare_strings(exact,L1,L2,Comp),!.
nms_compare(L1,Comp,_):-
	atom(L1),
	Comp = (<),
	!.
nms_compare(_,Comp,L2):-
	atom(L2),
	Comp = (>),
	!.
nms_compare(L1,Comp,L2):-
	mnld(L1,C1,_),
	mnld(L2,C2,_),
	compare_strings(exact,C1,C2,Comp),!.



%%%%%%%%%%%%%%%%
%% Reasoning
%%%%%%%%%%%%%%%%




% Remove redundant clauses from Active
% Variables:
%	i1: Active clause set
%	i2: ID of activated passive clause
%	i3:	its length
%	i4:	its disjunction list
%	i5:	assumptions, if any
%	i6: in accumulator for updated active list
%	o7:	out-accumulator
optimize_active([], _, _, _, _, In, In):-!.
optimize_active([[OA, NCID]|RestA], CIDP, LP, DisP, CondP, In, Out):-
	CIDA is 0 - NCID,
	clause(CIDA, LA, DisA, CondA),							% obtain clause data
	( clause_redundant(DisA,DisP,LA,LP), 
	  CondA == CondP
		->	inactivate_clause(CIDA, [subsumed_by, CIDP]),
			!, optimize_active(RestA, CIDP, LP, DisP, CondP, In, Out)
	; ord_add_element(In, [OA, NCID], Out1),
	 !, optimize_active(RestA, CIDP, LP, DisP, CondP, Out1, Out)
	).


% Check whether a clause is redundant with respect to another clause
% Variables:
%	i1:	disjunction list of clause to be checked for redundancy
%	i2:	disjunction list of clause to be compared to
%	i3:	length of i1 clause
%	i4:	length of i2 clause
clause_redundant(DisA,DisP,LA,LP):-			%% add non-ground test
	ground(DisA),
	ground(DisP),
	LP < LA,
	sort(DisA, DA1),
	sort(DisP, DP1),
	ord_subset(DP1, DA1),
	!.




%% Discount Saturation algorithm



discount:-
	process_unprocessed,			% Try processing all clauses in the set unprocessed, fail when inconsistency found
	process_passive,
	!,discount.
discount:-!.


% Loop through unprocessed clauses until empty
% Called by: discount
process_unprocessed:-
	clause(CID,L,Dis,u),							% pop last asserted u-clause from the stack	
	( L == 0										% fail if it is an empty clause				
		-> asserta(stopped([inc, CID])),
		   !,fail
	; true
	),
	( internally_redundant(CID,L,Dis,Reason1)		% internal retention test negeative
		-> inactivate_clause(CID, Reason1),
		   fail										% backtrack to pick next unprocessed clause 
	; true
	),
	( externally_redundant(CID, Reason2)				% external retention test negative
		-> inactivate_clause(CID, Reason2),
		   fail										% backtrack to pick next unprocessed clause
	; true
	),
	inf_simplify(CID,Dis,CIDout,p),					% forward simplify this clause
	( CIDout == 0									% fail if simplification would have generated an empty clause				
		-> !,fail
	;	true
	),
	clause(CIDout,Lout,DisOut,_),
	bwd_simplify(CIDout,Lout,DisOut),							% simplify active clauses using this clause
	factor_clause(CIDout,DisOut,DisOut2,Vout),
	( DisOut \== DisOut2,
	  create_conclusion_clause(-1, DisOut2, [factoring, CIDout, Vout], i, u, _, _)
	; true
	),
%	!,process_unprocessed.
fail.
process_unprocessed:-!.


% Forward simplify
%	Always succeeds
% Called by:
%	process_unprocessed
%	process_passive
% Variables:
%	i1: clause ID
%	i2: list of disjunctions of the clause to simplify
%	o3:	ID of simplified clause (=i1 when no simplification achieved)
%	i4: clause set in which to put the simplified clause (p when called from unprocessed, a when from passive
fwd_simplify(CID,[[0,identical,I1,I2]],CIDout,Where):-		% positive identity unit clause
	writeln(CID),
	I2 \== I1,
	identity(_,I1,IN),										% I1 is already determined as carrying priority
	inactivate_clause(CID, [idp, IN]),
	create_conclusion_clause(-1, [[0,identical,I1,I2]], [id,CID,IN], i, Where, _, CIDout),
	asserta_once(identity(I2, I1, CIDout)),
	replace_identities(I2,I1,[idr,CIDout,IN]),!.
fwd_simplify(CID,[[0,identical,I1,I2]],CIDout,Where):-		% positive identity unit clause
	I2 \== I1,
	identity(_,I2,IN),
	inactivate_clause(CID, [idp, IN]),
	create_conclusion_clause(-1, [[0,identical,I1,I2]], [id,CID,IN], i, Where, _, CIDout),
	asserta_once(identity(I1, I2, CIDout)),
	replace_identities(I1,I2,[idr,CIDout,IN]),!.
fwd_simplify(CID,[[0,identical,I1,I2]],CIDout,Where):-		% positive identity unit clause
	identity(I1,I3,IN),
	I2 \== I3,
	inactivate_clause(CID, [idp, IN]),
	create_conclusion_clause(-1, [[0,identical,I1,I2]], [id,CID,IN], i, Where, _, CIDout),
	asserta_once(identity(I2, I3, CIDout)),
	replace_identities(I2,I3,[idr,CIDout,IN]),!.
fwd_simplify(CID,[[0,identical,I1,I2]],CIDout,Where):-		% positive identity unit clause
	identity(I2,I3,IN),
	I1 \== I3,
	inactivate_clause(CID, [idp, IN]),
	create_conclusion_clause(-1, [[0,identical,I1,I2]], [id,CID,IN], i, Where, _, CIDout),
	asserta_once(identity(I1, I3, CIDout)),
	replace_identities(I1,I3,[idr,CIDout,IN]),!.
fwd_simplify(CID,[[0,identical,I1,I2]],CID,Where):-			% positive identity unit clause
	I2 \== I1,
	retract(clause(CID,_,_,_)),								% move it to Where
	asserta_once(clause(CID,1,[[0,identical,I1,I2]],Where)),
	identity_priority([0|[identical,I1,I2]],CID,P),
	(	P == 1
			->	replace_identities(I2,I1,[idr,CID,CID])
	;	replace_identities(I1,I2,[idr,CID,CID])
	),!.
fwd_simplify(CID,DisIn,CIDout,Where):-
	rem_red_lit(CID,DisIn,[],DisOut,[],Rout),					% remove redundant literals
	(	DisOut == []											% if empty clause: inconsistency
			->	CIDout = 0,
				inactivate_clause(CID, Rout),
				create_conclusion_clause(-1, [], Rout, i, u, _, ClauseID),
				asserta(stopped([inc, ClauseID])) 
	;	DisOut == DisIn											% no simplification achieved
			->	retract(clause(CID,L,_,Set)),						% move it to Where
				asserta_once(clause(CID,L,DisIn,Where)),
				CIDneg is 0 - CID,
				( Where == p
					->	retract(pas(PAS)),
						clausedat(CID, _,_,_,_,_,PO),
						ord_add_element(PAS,[PO,CIDneg],NPAS),
						asserta(pas(NPAS))
				; Set == p,
				  pas(PAS),
				  member([MD,CIDneg],PAS)
					->	retract(pas(PAS)),
						ord_del_element(PAS,[MD,CIDneg],NPAS),
						asserta(pas(NPAS))
				; true
				),
				CIDout = CID
	; 	inactivate_clause(CID, Rout),
		create_conclusion_clause(-1, DisOut, Rout, i, Where, _, CIDout)
	),
	!.



make_fact([TF|T],FN,Reason):-				% otherwise
	increment(facts, FN),					% 	generate fact ID
	(	\+farmed(_,T,_),
		uterm(TID, T),
		uterm(TID, X),
		X\==T,
		asserta_once(farmed(TID, T, []))	% mark its term as not farmed
	;	true
	), 
	list_depth(T,LDT),
	plus(LDT,-1,LDTF),
	asserta_once(f([TF|T],FN,Reason,LDTF)),!.	% assert as new fact


% i,i,o
identity_priority([0|[identical,A1i,A2i]],FN,P):-
	(	ground(A1i),
		ground(A2i)
			->	term_to_atom(A1i,A1), atom_length(A1, A1L),
				term_to_atom(A2i,A2), atom_length(A2, A2L),
				(	A1L > A2L
						->	asserta_once(identity(A1i, A2i, FN)),
							P = 2
				;	asserta_once(identity(A2i, A1i, FN)),
					P = 1
				)
	;	ground(A1i)
			->	asserta_once(identity(A1i, A2i, FN)),
				P = 2
	;	asserta_once(identity(A2i, A1i, FN)),
		P = 1
	),!.



	



% Simplify clauses in 'active' based on a clause in focus
% Variables:
%	i1:	ID of the clause in focus
%	i2:	length of its disjunctions
%	i3: the list of disjunctions
bwd_simplify(B_CID,1,[[TF|Lit]]):-		% if the clause in focus is a unit clause, remove negated literal from clauses
	(TF == 0 -> NTF = -1 ; NTF = 0),
	duplicate_term(Lit,LitD),
	literal(LitD,NTF,_,A_CID,_,TID,_,_,_,_),		% find a clause which has the literal in opposite truth 
	clause(A_CID,_,Adis,Set),				% pick a clause
	bws(ClauseTypes),						% retrieve the list with allowed clause types for bwd_simplify
	member(Set, ClauseTypes),				% if the picked clause is of a permitted type
	literal(Term,NTF,_,A_CID,_,TID,_,_,_,_),		% obtain the exact term
	subsumes_term(Lit,Term),				% assess whether Lit is equal or more general than Tern
	exact_member_pos(Adis, [NTF|Term], [], Out),	% remove the negated literal
	Out\==Adis,										% if removing was successful
	inactivate_clause(A_CID, [elimf,B_CID]),		% inactivate the clause
	\+clause(_,_,Out,_),
	\+externally_redundant(Out, _),				% external retention test negative
	create_conclusion_clause(-1, Out, [replf,A_CID,B_CID], i, u, _, _),	% create the simplified clause in 'unprocessed'
	fail.								% check another clause
bwd_simplify(_,_,_):-!.




process_passive:-
	\+clause(_,_,_,p),					% If the passive clause set is empty, 
	!,fail.								%	fail, so discount terminates with 'unknown' or 'satisfiable'
process_passive:-
	clause(CID,0,[],p),					% If there is an empty clause in the passive set 
	asserta(stopped([inc, CID])),
	!,fail.								%	fail, so discount terminates with 'inconsistent'
process_passive:-
	sfc(CID,Dis),			% select the 'best' clause (ID, disjunctions) out of passive clauses
	fwd_simplify(CID,Dis,CIDout,a),		% forward simplify this clause
	( CIDout == 0									% fail if simplification would have generated an empty clause				
		-> asserta(stopped([inc, CIDout])),
		   !,fail
	;	true
	),
	clause(CIDout,Lout,DisOut,_),
	( internally_redundant(CIDout,Lout,DisOut,Reason1)		% internal retention test negeative
		-> inactivate_clause(CIDout, Reason1),
		   fail										% backtrack to pick next unprocessed clause 
	; true
	),
	( externally_redundant(CIDout, Reason2)				% external retention test negative
		-> inactivate_clause(CIDout, Reason2),
		   fail										% backtrack to pick next unprocessed clause
	; true
	),
	bwd_simplify(CIDout,Lout,DisOut),							% simplify active clauses using this clause
	factor_clause(CIDout, DisOut,DisOut2,Vout),
	( DisOut \== DisOut2,
	  create_conclusion_clause(-1, DisOut2, [factoring, CIDout, Vout], i, u, _, _)
	; true
	),
	inference_selection(CIDout, Lout, DisOut), 
	!.
process_passive:-
	stopped([for]),						% If thresholds for resolution reached 
	!,fail.								%	fail, so discount terminates with 'unknown'
process_passive:-!.	
	

% Variables:
%	i1:	ID of the clause to find inferences for
resolution(CID):-
	clause(CID,_,Dis,_),					%	obtain clause data
	duplicate_term(Dis,DisD),				%	duplicate the disjunction list with fresh variables
	nth1(P,DisD,[TF|[Pred|Args]]),			%	pick a literal from the disjunctions
	Pred \== identical,						%	exclude identities
	(TF == 0 -> NTF = -1 ; NTF = 0),		%	create in NTF the negation of the the truth of that literal
%	(TF == 0 -> NTF = -1 ; fail),		%	create in NTF the negation of the the truth of that literal
	literal([Pred|Args],NTF,_,CIDA,_,_,Pa,_,_,_),%	look in the term index for clause which has a term with opposite truthvalue that unifies with the term
	CIDA \== CID,							%		if the term is in the same clause, backtrack to the next index term
	clause(CIDA,_,DisAct,a),				%	if it is a different clause, pick it disjunction list
	(	resolved(CID, P, CIDA, Pa)			%		also if the term has already been tried for the two clauses
			->	fail
	;	resolved(CIDA, Pa, CID, P)			%		also if the term has already been tried for the two clauses but with 2nd clause first
			->	fail
	;	asserta(resolved(CID, P, CIDA, Pa)),
		true
	),
	duplicate_term(DisAct,DisA),			%	create a copy with new variables
	nth1(P, DisD,[TF|T1]),					%	pick the term from the CID clause in its orginal form
	nth1(Pa,DisA,[NTF|T2]),					%	idem for the CIDA clause
	nth1(P, DisD,_,R1o),					%	delete the literal from DisD resulting in R1o
	nth1(Pa,DisA,_,R2o),					%	idem for the CIDA clause
	TA = [[dummy|T1],[dummy|T2],R1o,R2o],	%	create a temporal term TA with the components constructed
%	writeln(TA),
	unifiable(T1,T2,U),
	(	\+acyclic_term(TA)
		-> trace,
			write_canonical(TA),writeln(""),
			cyclic_bindings(U,[],UID),
			append([R1o,R2o,UID],App),					%	resolution step
			sort(App,Appo),							%	sort result
			length(Appo,Lappo),
			nth1(Lappo,Appo,Xappo,Rappo),
			write_canonical(Xappo),writeln(""),
			write_canonical(Rappo),writeln(""),
			trace
	),
	unify_with_occurs_check(T1,T2),			%	safe unify the opposite literals with consequent unifaction of the variables in TA
%	writeln(TA),
	append(R1o,R2o,App),					%	resolution step
	sort(App,Appo),							%	sort result
%	write_canonical(Appo),writeln(""),
%	trace,
	addable(Appo, a),
	create_conclusion_clause(-1, Appo, [resolution, CID, P, CIDA, Pa], i, u, L1, NCID),
	factor_clause(NCID,Appo,DisOut2,Vout),
	( length(DisOut2,L2),
	  L2 < L1
	   -> create_conclusion_clause(-1, DisOut2, [factoring, NCID, Vout], i, u, _, _)
	; true
	),
	!.

% Variables:
%	i1:	ID of the clause to find inferences for, i.e. the 'given clause'
ordered_resolution(CID):-
	clause(CID,_,Dis,_),					%	obtain given clause data
	duplicate_term(Dis,DisD),				%	duplicate the disjunction list with fresh variables
	lico(CID,CIDord,_),						%	obtain the given clause's literal ordering

	%	try all literals of the given clause and for all these literals all active clauses that may lead to
	%	resolutions satisfying all criteria for ordered resolution
	member([_, P], CIDord),					%	BTP-1: start with highest ordered literal
	nth1(P,DisD,[TF|[Pred|Args]]),			%	pick the literal
	Pred \== identical,						%	exclude identities
	(TF == 0 -> NTF = -1 ; NTF = 0),		%	create in NTF the negation of the truth of that literal
	literal([Pred|Args],NTF,_,CIDA,_,_,Pa,_,_,_),	%	BTP-2: look in the term index for clause which has a term with  
													%	opposite truth value and that unifies with the term
	CIDA \== CID,							%	it may not be the same clause
	clause(CIDA,_,DisAct,a),				%	if it is a different clause, and it is active, pick its disjunction list
	(	resolved(CID, P, CIDA, Pa)			%	ensure the two clauses haven't been resolved yet
			->	fail
	;	resolved(CIDA, Pa, CID, P)	
			->	fail
	;	true
	),
	duplicate_term(DisAct,DisA),			%	create a copy of the active clause's disjunctions with new variables
	nth1(P, DisD,[TF|T1]),					%	pick the term from the CID clause in its orginal form
	nth1(Pa,DisA,[NTF|T2]),					%	idem for the CIDA clause
	nth1(P, DisD,_,R1o),					%	delete the literal from DisD resulting in R1o
	nth1(Pa,DisA,_,R2o),					%	idem for the CIDA clause
	append([[dummy|T1],[dummy|T2],R1o,R2o],_),	%	create a temporal term with the components constructed to allow complete unification
	unify_with_occurs_check(T1,T2),			%	safe unify the opposite literals with consequent unification 
											%	of the variables in the temporal term
	%	now create or retrieve for each key component for the resolution process a non-clause disjunction 
	%	including associated ordering data
	( 	clause(CR1o,_,R1o,d) -> true ; create_conclusion_clause(-1, R1o, resa, t, d, _, CR1o) ),
	( 	clause(CR2o,_,R2o,d) -> true ; create_conclusion_clause(-1, R2o, resa, t, d, _, CR2o) ),
	( 	clause(CT1,1,[[TF|T1]],d) -> true ; create_conclusion_clause(-1, [[TF|T1]], resa, t, d, _, CT1) ),
	( 	clause(CT2,1,[[NTF|T2]],d)-> true ; create_conclusion_clause(-1, [[NTF|T2]], resa, t, d, _, CT2) ),

	%	check whether the unification satisfies the ordered resolution criteria
	( TF == 0							% if the given clause is the one with positive resolving literal, do it as follows
	   -> lico(CT1,[[B_ord,_]],_),		%  retrieve the literal ordering position of the positive key literal after substitution	
		  lico(CT2,[[A_ord,_]],_),		%  retrieve the literal ordering position of the negative key literal after substitution	

		  lico(CR1o,CR1ord,_),			% retrieve the literal ordering position of the remaining literals in
										%	the clause of the positive key literal after substitution	
		  length(CR1ord, LCR1),			% determine its length
		  nth1(LCR1,CR1ord,[D_ord,_]),	% retrieve the order of the lowest ranked literal therein
		  D_ord > B_ord,				% only accept the resolution thus far if this condition satisfied
		  
		  lico(CR2o,CR2ord,_),			% retrieve the literal ordering position of the remaining literals in
										%	the clause of the negative key literal after substitution	
		  length(CR2ord, LCR2),			% determine its length
		  nth1(LCR2,CR2ord,[C_ord,_]),	% retrieve the order of the lowest ranked literal therein
		  C_ord >= A_ord,				% accept the resolution if this condition satisfied
		  !
	; TF == -1
	   -> lico(CT1,[[A_ord,_]],_),		%  retrieve the literal ordering position of the negative key literal after substitution	
		  lico(CT2,[[B_ord,_]],_),		%  retrieve the literal ordering position of the positive key literal after substitution	

		  lico(CR1o,CR1ord,_),			% retrieve the literal ordering position of the remaining literals in
										%	the clause of the negative key literal after substitution	
		  length(CR1ord, LCR1),			% determine its length
		  nth1(LCR1,CR1ord,[C_ord,_]),	% retrieve the order of the lowest ranked literal therein
		  C_ord >= A_ord,				% accept the resolution if this condition satisfied
		  
		  lico(CR2o,CR2ord,_),			% retrieve the literal ordering position of the remaining literals in
										%	the clause of the positive key literal after substitution	
		  length(CR2ord, LCR2),			% determine its length
		  nth1(LCR2,CR2ord,[D_ord,_]),	% retrieve the order of the lowest ranked literal therein
		  D_ord > B_ord,				% only accept the resolution thus far if this condition satisfied
		  !
	),
	   
	%	When here, the resolution is acceptable 
	append(R1o,R2o,App),					%	resolution step
	sort(App,Appo),							%	sort result
	asserta(resolved(CID, P, CIDA, Pa)),
	addable(Appo, a),
	create_conclusion_clause(-1, Appo, [resolution, CID, P, CIDA, Pa], i, u, L1, NCID),
	factor_clause(NCID,Appo,DisOut2,Vout),
	( length(DisOut2,L2),
	  L2 < L1
	   -> create_conclusion_clause(-1, DisOut2, [factoring, NCID, Vout], i, u, _, _)
	; true
	),
	fail.
ordered_resolution(_):-!.


% Variables:
%	i1:	ID of the clause to find inferences for
ground_ordered_resolution(CID):-
	clause(CID,_,Dis,_),					%	obtain clause data
	ground(Dis),							%	ensure the given clause has no variables
	lico(CID,[POrd,P],_),					%	obtain the position of the maximal literal in the clause and in the ordering
	nth1(P,Dis,[TF|[Pred|Args]]),			%	pick the literal
	Pred \== identical,						%	exclude identities
	(TF == 0 -> NTF = -1 ; NTF = 0),		%	create in NTF the negation of the the truth of that literal
	literal([Pred|Args],NTF,_,CIDA,_,_,Pa,_,_,_),%	look in the term index for clause which has a term with opposite truthvalue that unifies with the term
	CIDA \== CID,							%	if the term is in the same clause, backtrack to the next index term
	clause(CIDA,_,DisAct,a),				%	if it is a different clause and active, pick its disjunction list
	ground(DisAct),
	lico(CIDA,[POrdA,_],_),				%	obtain the position of the maximal literal in the clause and in the ordering
	POrdA < POrd,							%	ensure the given's clause maximal literal is greater than the active clause
	(	resolved(CID, P, CIDA, Pa)			%	there should not have been a prior attempt to resolve the two literals
			->	fail
	;	resolved(CIDA, Pa, CID, P)			
			->	fail
	;	asserta(resolved(CID, P, CIDA, Pa)),
		true
	),
	nth1(P, Dis,_,R1o),						%	delete the literal from Dis resulting in R1o
	nth1(Pa,DisAct,_,R2o),					%	idem for the CIDA clause
	append(R1o,R2o,App),					%	resolution step
	sort(App,Appo),							%	sort result
	addable(Appo, a),
	create_conclusion_clause(-1, Appo, [resolution, CID, P, CIDA, Pa], i, u, L1, NCID),
	( length(DisOut2,L2),
	  L2 < L1
	   -> create_conclusion_clause(-1, DisOut2, [factoring, NCID, Vout], i, u, _, _)
	; true
	),
	fail.
ground_ordered_resolution(_):-!.


cyclic_bindings([],In,In):-!.
cyclic_bindings([H|T],In,Out):-
	H=..New,
	nth1(2,New,L1),
	nth1(3,New,L2),
	!, cyclic_bindings(T,[[-1,identical,L1,L2]|In],Out).
	

% Variable:
%	i1:	disjunction of literals
%	i2:	type of clauses to part redundancy with, i.e. a subsuming clause exist
addable(Dis, Ctype):-
	acyclic_term(Dis),
	\+clause(_,_,Dis,_),
	\+tautology(Dis,_),
	\+contains_fact(Dis,_),
	\+part_redundant(Dis,Ctype,_),
	!.

%% rewrite efficient!
% Variables:
%	i1:	given disjunction of literals
%	i2:	type of clauses to check with
%	o3:	unique ID of clause that subsumes the clause with disjunction list i1
part_redundant(Dis,Ctype,CID):-
	duplicate_term(Dis, DisD),				% the later append() performs unification/substitution, so keep original clause
	length(DisD,L1),						% obtain the length
	clause(CID,[NCPL,_],NCPdis,Ctype),		% BTP1: pick within the allowed clause type a clause, if still any available
	NCPL<L1,								% if not smaller, pick other clause
	duplicate_term(NCPdis, NCPdisD),		% keep original too
	append(NCPdisD,_,DisD),					% BTP2: check whether the clause's disjunction list is a subset of the given disjunctions
	subsumes_term(DisD,Dis),				% check whether the substituted given disjunction is more general or equal to the original
	!.



% Select a passive clause to be processed
% Called by:
%	process_passive
% Variables: 
%	o1: the ID of the retrieved clause
%	o2: the ordered set of disjunctions
sfc(CID,Dis):-
	toc(TOC),								% get clause ID of last clause generated from ontology and data input
	max_threshold(CLAR,TFL,TRL),			% retrieve threshold settings
	(	clause(CID, _, Dis, p),
		ground(Dis)
	;	true
	),
	pas(PAS),								% retrieve the ordered passive clause set 
	nth1(_, PAS, [_, CIDneg], Rest),			% pick and backtrack to find clause within threshold settings
	CID is CIDneg * -1,
	clause(CID, CL, Dis, p),
	clausedat(CID, SD, _, _, RLS, _, _),
	(	CID =< TOC
			-> true
	;	CLAR >= CL,						%	 length within threshold
		TFL >= SD,						%	 clause function level embedding within threshold limit
		TRL >= RLS						%	 clause function recursion level within the threshold
			-> true
	;	fail
	),
	retract(pas(PAS)),
	asserta(pas(Rest)),	!.
sfc(_,_):-
	asserta(stopped([for])),					% if max for all thresholds reached
	fail.
	




% Clause retention test
%	True:	if i1 fails the retention test
% Called by:
%	process_unprocessed
%	process_passive
% Variables
% 	i1: ID of clause considered for retention
%	i2: number of disjunctions in the clause
%	i3: ordered list of disjunctions of the clause
%	o4: reason
internally_redundant(_,_,Dis, [cyclic]):-			% contains cyclic term
	\+acyclic_term(Dis),!.
internally_redundant(_,_,Dis,[taut, Taut]):-	% contains tautology
	tautology(Dis,Taut),!.
internally_redundant(_,L,Dis,Reason):-			% contains unit-clause without being one
	L > 1,
	contains_fact(Dis,Reason),!.  
internally_redundant(_,_,_,_):-!,fail.


% Inactivate clause i1 when there exist an active parent clause of it
% Variables:
%	i1:	the clause to be checked for redundancy
%	o2: the reason for the redundancy
externally_redundant(CID,[variant, X]):-	% check for variants (A is VOF B if A==B after variable re-writing)
	number(CID),							% if number given 
	clause(CID,[L,_],CD,_),						% retrieve the clause
	clause(X,[L,_],XD,W),						% pick second clause with same length
	active_clause(W),								% which is not eliminated
	X \== CID,								% with different clause ID
	CD =@= XD,								% and check for the variable-rewrite equality
	!.
externally_redundant(CDIS,[variant, X]):-
	is_list(CDIS),
	length(CDIS,L),
	clause(X,[L,_],XD,T),						% pick second clause with same length
	memberchk(T,[a, []]),
	CDIS =@= XD,								% and check for the variable-rewrite equality
	!.

% Variables:
%	i1:	list of disjunctions
%	o2: explanation tag for found fact
contains_fact([],_):-!,fail.
contains_fact([[0,identical,A,B]|_],[lit_iden]):-		% Check for literal expressing literal identity  
	A == B,
	!.
contains_fact([[0,identical,A,B]|_],[iden, CID]):-	% Check for literal exhibiting semantic identity with unit clause
	clause(CID,[1,_],[[0,identical,C,D]],a),			
	(	A == C, B == D
	;	A == D, B == C
	),
	!.
contains_fact([[TF|[P|Args]]|_],[iden_subs, CID]):-	% Check for literal unifying with unit-clause
%%check
	P \== identical,
	duplicate_term([TF|[P|Args]],Term),
	clause(CID,[1,_],[Term],_),				% if it unifies with a unit-clause
	Term == [TF|[P|Args]],
	!.												%			the clause is not factless
contains_fact([_|T],R):-!,contains_fact(T,R).		%	otherwise process the next literal on the list



%%%%%%%%%%%%%%%%%%%%%
%% Inference rules %%
%%%%%%%%%%%%%%%%%%%%%

% Variables:
%	i1:	Unique ID of the given clause
%	i2:	its length
%	i3:	its disjunction list
inference_selection(CID, L, Dis):- 
	%% Equality Resolution
	(	L>1,
		nth1(P, Dis, [-1,identical,A,B], Rest),
		unify_with_occurs_check(A,B),
		addable(Rest, a),
		create_conclusion_clause(-1, Rest, [eqres, CID, P], i, u, _, _)
	; true
	),
	resolution(CID),
	!.
inference_selection(_,_,_):-!.


%% Positive and negative factoring
% Variables:
%	i1:	ID of clause to factor
%	i2:	list of disjunctions to be factored
%	o3:	factored list of disjunctions
%	o4:	most general unifier used in factoring
factor_clause(_, DisIn, Outi, factoring):-
	\+ground(DisIn),
	member([TF|[P|Args1]],DisIn),
	\+ground([TF|[P|Args1]]),
	member([TF|[P|Args2]],DisIn),
	Args1\==Args2,
	length(Args1,L),
	length(Args2,L),
	unifiable([TF|[P|Args1]],[TF|[P|Args2]],Vars),
	instantiate_vars(Vars,DisIn,R),
	sort(R, Outi),
	length(DisIn,L1),
	length(Outi,L2),
	L2 < L1,writeln(Outi),trace,
%	addable(DisIn, a),
	!.
factor_clause(_, Out, Out, []):-!.


%% should be able to deduce [-1,precedes,A,A] but doesn't.
% Variables:
%	i1: clause ID
%	o2: clause ID of factored clause or input ID when no factoring achieved
c_factored(CA1, NCID):-
	clause(CA1, [CL,_], D, Co),												% BTP1: retrieve the clause by its ID
	CL > 1,
	active_clause(Co),															% check whether not eliminated
	c_dat(CA1,W,_,_,_),													% retrieve the source type W
	nth1(P1,D,P1L,R1),													% BTP2: separate a literal from the other literals
	nth1(P2,D,P2L,R2),													% BTP3: again
	P1 \== P2,															%	but ensure it is not one in the same position
	duplicate_term([D,P1L,R1,Co],[OD1,OP1,OR1,Co1]),
	duplicate_term([D,P2L,R2,Co],[OD2,OP2,OR2,Co2]),
	_ = [D, OD1, OD2, Co, Co1, Co2, P1L, R1, P2L, R2],
	unify_with_occurs_check(P1L, P2L),									% try to unify the literals, and if it succeeded ...
	( subsumes_term(OP2, OP1),											% if the 2nd literal is more general than the first one
	  \+subsumes_term(OP1, OP2)											%	and not vice versa (otherwise too general )
		->	sort(OR1,R1CS),												%	sort the remainder of the clause 
			pre_clause_add_check(R1CS),									%	check whether the reduced clause is redundant
			add_new_clause([R1CS, [factored_out, CA1, P1], W, W, Co], NCID),	%		and if not, create it as new clause with same source type W
			eliminate_clause(CA1, [factored_out, NCID, P1])
	; subsumes_term(OP1, OP2),											% do similarly if the 1st literal was more general
	  \+subsumes_term(OP2, OP1)
		->	sort(OR2,R2CS),
			pre_clause_add_check(R2CS),
			add_new_clause([R2CS, [factored_out, CA1, P2], W, W, Co], NCID),
			eliminate_clause(CA1, [factored_out, NCID, P2])
	; NCID = CA1														
	),!.
c_factored(CA1, CA1):-!.




farm_facts:-
	inc([]),
	threshold(_,MSD,_),
	f([_|FactTerm],_,_,MSDF),					% retrieve the term from a fact
	MSD >= MSDF,
	farm(FactTerm),							% farm the term
	fail.
farm_facts:-!.	


% i
farm([P|Args]):-				% attempt to instantiate clauses with  Term
	farmed(TID,[P|Args],Clauses),
	findall(CID, literal([P|Args],_,_,CID,_,_,_,_,_,_), CIDs),
	subtract(CIDs, Clauses, Result),
	sort(Result,R),
	(	R \== []
			->	instantiate_clauses(R, [P|Args], TID, Clauses, Out),
				retract(farmed(TID,[P|Args],Clauses)),
				asserta_once(farmed(TID,[P|Args],Out))
	;	true),!.
farm(_):-!.

/*
% i,o
farm(Term, FN):-							% attempt to instantiate clauses with  Term
	literal(Term,_,_,TermInClauseID,_,_,_,_,_,_),		% obtain the clauses which have a pattern that match the term
	instantiate_clause(TermInClauseID, Term, FN),
	fail.
farm(_,_):-!.
*/

instantiate_clauses([], _, _, Out, Out):-!.
instantiate_clauses([H|R], Term, FN, In, Out):-
	instantiate_clause(H, Term, FN),
	!,instantiate_clauses(R, Term, FN, [H|In], Out).
instantiate_clauses([H|R], Term, FN, In, Out):-
	!,instantiate_clauses(R, Term, FN, [H|In], Out).



generate_facts(_):-
	inc([]),
	pp(_,Term),
	resolve_by_term(Term),
	eliminate_clauses_with_facts,
	remove_terms_negating_facts,
	(	empty_clause
			-> !,fail
	;	true),
	\+unit_clauses_left,
	fail.
generate_facts(_):-
	inc([]),
	farmed(_,Term,[]),
	farm(Term),
	resolve_by_term(Term),
	eliminate_clauses_with_facts,
	remove_terms_negating_facts,
	(	empty_clause
			-> !,fail
	;	true),
	\+unit_clauses_left,
	fail.
generate_facts(Nstart):-
	inc([]),
	counter(facts,N),
	write("Number of facts: "),writeln(N),
	N > Nstart,
	farm_facts,
	generate_facts(N).
generate_facts(_):-!.



	

empty_clause(CID):-
%	clause(CID,[0,_],[],_),
%	\+cl_stati(CID,_),
	writeln(""),
	writeln("Inconsistency found!!!"),
	build_history([CID],[],[],[],[],[Clauses,Facts,UsedTerms,History]),
	maplist(farmed, UsedTerms, UsedTermIDs, _),		% collect all terms and their IDs used for the proof
	assert(gts(TA,TB,[TA,"   ",TB])),				% create a temporary predicate to combine Term IDs and their terms 
	maplist(gts,UsedTerms,UsedTermIDs,TermLines),	% perform the combinations an store them as a list in TermLines
	writeln(""),
	writeln("Terms used for proof:"),
	maplist(writeln,TermLines),						% write the list of terms used
	retractall(gts(_,_,_)),
	maplist(f,Terms,Facts,Sources,_),					% similarly for facts used
	assert(gts(A,B,C,[B,"   ",A,"   ",C])),
	maplist(gts,Terms,Facts,Sources,Lines),
	retractall(gts(_,_,_,_)),
	writeln(""),
	writeln("Facts used for proof:"),
	maplist(writeln,Lines),
	writeln(""),
	writeln("Clauses used for proof:"),				% and for clauses used
	maplist(clause,Clauses,_,Dis,Cond),
	maplist(renum_vars,Dis,Cond,DisO,Condo),
%	assert(gts(A,B,C,[A,"   ",B, "  OR  ", C])),
	assert((gts(A,B,C,ABC):-(C==[]->ABC=[A,"   ",B];C=[e,CX],(CX==[]->ABC=[A,"   ",B];ABC=[A,"   ",B, "  OR  ", C])))),
	maplist(gts,Clauses,DisO,Condo,Clines),
	retractall(gts(_,_,_,_)),
	length(Clauses,LC),
	length(Wpar,LC),
	maplist(=([numbervars(true),quoted(true),nl(true)]),Wpar),
	maplist(write_term,Clines,Wpar),
	writeln(""),
	writeln("Proof:"),								% write the proof out
	write_proof(History),
	writeln(""),
	writeln(""),
	write("Inconsistent with axioms: "),
	inc(INC),
	sort(INC,INC2),
	writeln(INC2),
	writeln(""),
	writeln(""),
	!.
empty_clause(_):-!.


renum_vars(Term1In,Term2In,Term1Out,Term2Out):-
	numbervars([Term1In,Term2In],0,_,[singletons(true)]),
	Term1Out=Term1In,
	Term2Out=Term2In.

write_proof([]):-!.
write_proof([A|R]):-
%	writeln(""),
%	write_canonical(A),
	writeln(A),
	!, write_proof(R).

% i,i,i,i,o
build_history([],Done,Facts,Terms,In,[DoneOut,FactsOut,TermsOut,Out]):-
	sort(Done,DoneOut),
%	sort(Facts,FactsOut),
%	sort(Terms,TermsOut),
	reverse(In,Out),!.
build_history([CID|Rest],Done,Facts,Terms,In,Out):-
	member(CID,Done),
	!, build_history(Rest,Done,Facts,Terms,In,Out).
build_history([CID|Rest],Done,Facts,Terms,In,Out):-
	(cl_stata(CID, [ont_clause,_,A,B])
			->  atomic_list_concat(["Clause ", CID, " derived from disjunction ", A, " derived from Axiom ", B, "."], Com),
				Output = [Com],
				NextFacts = Facts,
				retract(inc(INC)),
				asserta(inc([B|INC])),
				NextTerms = Terms,
				NextIn = Rest
	;	cl_stata(CID, [factored_out, N3, P])
			->	NextTerms = Terms,
				NextIn = [N3|Rest],
				atomic_list_concat(["Clause ", CID, " derived from clause ", N3, " through factoring out literal ", P, "."], Com),
				Output = [Com]
	;	cl_stata(CID, [slr, C1, PC1, C2, PC2]),
				NextIn = [C1|[C2|Rest]],
				NextTerms = Terms,
				atomic_list_concat(["Clause ", CID, " is the resolvent of clauses ", C1, " and ", C2, 
									" with resolved literals ", PC1, " and ", PC2, " respectively."],Com),
				Output = [Com]
	;	cl_stata(CID, [eqres, C1, P]),
				NextIn = [C1|Rest],
				NextTerms = Terms,
				atomic_list_concat(["Clause ", CID, " is the equality resolvent of clause ", C1,
									" using the mgu of the terms in inequality ", P, "."],Com),
				Output = [Com]
	;	cl_stata(CID, [r_red, C, Reasons]),
				NextTerms = Terms,
				atomic_list_concat(["Clause ", CID, " is a simplification of clause ", C, "."],Com),
				maplist(proof_output_part, Reasons, Outs),
				append(Outs, [Com], Output),
				findall(X, member([nuc|X], Reasons), Xs),
				flatten([C|Xs], Xsf),
				append(Xsf,Rest,NextIn)
	;	cl_stata(CID, [idr, ToDo, IdCID, ToRepl, WithWhat])
			->	NextIn = [ToDo|[IdCID|Rest]],
				NextTerms = Terms,
				atomic_list_concat(["Clause ", CID, " is a rewriting of clause ", ToDo, " by substituting ",
									ToRepl, " with ", WithWhat, " because of identity clause ", IdCID, "."], Com),
				Output = [Com]
				
	;	cl_stata(CID, [red, Vout])
			->	NextTerms = Terms,
				atomic_list_concat(["Clause ", CID, " simplified by means of: "], Com),
				maplist(proof_output_part, Vout, Outs),
				append(Outs, [Com], Output),
				findall(X, member([nuc|X], Vout), Xs),
				flatten(Xs, Xsf),
				append(Xsf,Rest,NextIn)
	;	cl_stata(CID, [idr,C,FN1,FN2])
			->	NextIn = [C|Rest],
				NextTerms = Terms,
				(	FN1 == FN2
						-> NextFacts = [FN1|Facts],
						   atomic_list_concat(["Clause ", CID, " replaces clause ", C, " for identity fact ", FN1, "."],Com)
				;	NextFacts = [FN1|[FN2|Facts]],
					atomic_list_concat(["Clause ", CID, " replaces clause ", C, " due to identity facts ", FN1, " and ", FN2, "."],Com)
				),
				Output = [Com]
	;	cl_stata(CID, [repli, N3, A])
			-> 	atomic_list_concat(["Negated identity of ", A, " removed from Clause ",N3, "resulting in Clause ",CID,"."], Com),
				Output = [Com],
				NextIn = [N3|Rest],
				NextTerms = Terms,
				NextFacts = Facts
	;	cl_stata(CID, [subst, CID2, N3])
			->	NextTerms = [N3|Terms],
				NextIn = [CID2|Rest],
				NextFacts = Facts,
				atomic_list_concat(["Clause ", CID, " generated from Clause ", CID2, " by substitution with term ",N3,"."],Com),
				Output = [Com]
	;	cl_stata(CID, [d_clause,N3])
			->  atomic_list_concat(["Clause ", CID, " copied from input Clause ", N3, "."],Com),
				NextFacts = Facts,
				NextTerms = Terms,
				Output = [Com],
				NextIn = Rest
	;	cl_stata(CID, [split ,N3, Cond])
			->  term_to_atom(Cond, CA),
				atomic_list_concat(["Clause ", CID, " generated from Clause ", N3, " under conditionals ", CA, "."],Com),
				NextFacts = Facts,
				NextTerms = Terms,
				Output = [Com],
				NextIn = [N3|Rest]
	; 	writeln("Missed")
	)
	,
	flatten(NextIn,Flat),
	append(Output,In,NewIn),
	!, build_history(Flat, [CID|Done], NextFacts, NextTerms, NewIn, Out).



proof_output_part([dup, P], Out):-
	atomic_list_concat(["		removal of duplicated literal ", P, "."], Out),!.
proof_output_part([nuc, C1, C2], Out):-
	atomic_list_concat(["		removal of unit clause ", C2, " with opposite truth value in clause ", C1, "."], Out),!.
proof_output_part([nid, A], Out):-
	atomic_list_concat(["		removal of literal denying true identity of ", A, "."], Out),!.


% i,i,i
% Clause to instantiate, Term to instantiate with, Fact
instantiate_clause(ClauseID, Term, FID):- 
	clause(ClauseID, _, E, _ ),			% pick the list of disjunctions
%	writeln(E),
	\+ground(E),
	member([_|X],E),					% pick a clause from the list
	unify_with_occurs_check(Term,X),
	sort(E, R1),						% remove redundant terms
	\+tautology(R1,_),					% if binding result in tautology: fail
	\+contains_fact(R1,_),
	create_conclusion_clause(-1, R1, [subst, ClauseID,  FID], i, u, _, _),
	!.
instantiate_clause(_,_,_):-!. 




instantiate_vars([],Out,Out):-!.			% stop when no variable bindings left and return the result
instantiate_vars([=(V,F)|Rest],E,Out):-		% pick the first binding from the list of bindings
	replace(E,R,V,F),						% replace in E the variables with their bindings, resulting in R
	!,instantiate_vars(Rest,R,Out).			% apply the remaining bindings to R


% i,i,i,o
find_shortest_clause_by_term([TF|Term],S,N,CID):-
	threshold(_,MSD,MSC),
	literal(Term,TF,N,CID,_,_,_,_,_,_),		% pick a clause with length N and containing the fact
	clausedat(CID,MSDc,_,_,_,_,_),
	MSD >= MSDc,
	(	S == derived
			->	toc(TOC),						% it may not be an ontology clause
				CID > TOC
	;	true),!.
find_shortest_clause_by_term([TF|Term],S,N,CID):-
	threshold(_,MSD,MSC),
	literal(Term,TF,N,CID,_,_,_,_,_,_),		% pick a clause with length N and containing the fact
	literal(Term,TF,X,ID,_,_,_,_,_,_),			% check whether there are clauses with this fact with length > N
	clausedat(ID,MSDc,_,_,_,_,_),
	X > N,
	MSD >= MSDc,
	plus(N,1,NewN),					% if so, increase N to find the shortest
	!,find_shortest_clause_by_term([TF|Term],S,NewN,CID).





common_variables([],_):-!,fail.
common_variables(_,[]):-!,fail.
common_variables(V1,V2):-
	member(X1,V1),
	member(X2,V2),
	X1 == X2.
	


tautology(Dis,[tautology, P]):-
%%check
	member([-1|P1],Dis),
	member([0|P],Dis),
	P == P1,!.
tautology(Dis, [tautology, [0,identical,A,B]]):-
	member([0,identical,A,B],Dis),
	A == B,!.
%% generalize by congruence closure
tautology(Dis, [tautology, [[-1,identical,A,B],[-1,identical,B,C],[0,identical,A,C]]]):-
	member([-1,identical,A,B],Dis),
	A\==B,
	member([-1,identical,B,C],Dis),
	B\==C,
	member([0,identical,A,C],Dis),!.
tautology(Dis, [tautology, [[-1,identical,A,B],[-1,identical,B,C],[0,identical,[S,A,A],[S,C,C]]]]):-
	member([-1,identical,A,B],Dis),
	A\==B,
	member([-1,identical,B,C],Dis),
	B\==C,
	member([0,identical,[S,A,A],[S,C,C]],Dis),!.


% i,i,i,o
% first argument useless, avoids currently to have to change the calling clauses
skolem_cycle(RN,Index,Fact,0):-				% return 0 if a skolem-cycle at the threshold level was prevented
	sub_term([e,H,P],Fact),				 	% check whether the fact contains a skolem function of type H,
	threshold(_,_,X),						% if so, determine the accepted cycle-depth specified in the init-file
	cyclical_skolem(H,P,N),					% determine the depth of the cycle if one would occur
	(	X>=N								% fail the clause of the allowed depth-level is higher or equal than the actual depth that would arise
		-> fail
	;	increment(skcycle(RN,Index,H),_),	% otherwise, store then also which function H cycled, due to which rule RN of which axiom Index
		true, !).
skolem_cycle(_,_,_,1):-!.					% return 1 if a possible cycle would be below the threshold-level.


% i,i,o
cyclical_skolem(H, Fact, N):-			% determine the depth of a possible cycle
	sub_term([e,H,P], Fact),			% if the fact contains a skolem function of type H, AND
%	ground(P),							%	the arguments of the skolem function H are ground
	cyclical_skolem(H,P,M),				% recursively check all deeper levels
	N is M+1.
cyclical_skolem(_,_,0).


%%%%%%%%%%%%%%%
%% UTILITIES %%
%%%%%%%%%%%%%%%

% o, i
memberNestList(H,[H|_]).
memberNestList(X,[H|_]):-memberNestList(X,H).
memberNestList(X,[_|T]):-memberNestList(X,T).



% Computes the maximal recursion depths of the functor of a function
% Variables:
%	i1: function
%	o2:	maximal recursion depth (integer) of the head-functor
%	o3: recursion depth of non-head-functor token with deepest recursion
%	o4: s for skolem functor, n for non-skolem, thus FOL-function created in the logic
f_recursion([F|Args], F_max, R_max, FT):-
	( atom_concat(sk,Sk,F),
	  atom_number(Sk,_)
		-> FT = s
	; FT = n
	),
	listGrounder([F|Args],[],G),
	f_embedding(G, Chains),
	maplist(atomic_list_deconcat(!), Chains, Lists),
	token_max_frequency(F, Lists, F_max),
	findall(X, ( member(Y, Lists), 
				 member(X, Y) ),
			Xs),
	sort(Xs, Tokens),
	nth1(_, Tokens, F, Rest),
	tokens_max_frequency(Rest, Lists, [], MaxList),
	max_list(MaxList, R_max).


% 
tokens_max_frequency([], _, MaxList, MaxList):-!.
tokens_max_frequency([T|R], Lists, In, Out):-
	token_max_frequency(T, Lists, T_max),
	!,tokens_max_frequency(R, Lists, [T_max|In], Out).
	


% Variables:
%	i1: element of which the maximum frequency found for presence in several lists is to be computed
%	i2: list of lists
%	o3:	maximum frequency found 	
token_max_frequency(T, Lists, Max):-
	maplist(token_list_frequency(T), Lists, Fs),
	max_list(Fs, Max).



% Variables:
%	i1: element to count
%	i2: list
%	o3:	number of times i1 appears in i2	
token_list_frequency(T, L, F):-
	findall(_, member(T, L), Ls),
	length(Ls, F).



atomic_list_deconcat(Delim, Concat, Deconcat):-
	atomic_list_concat(Deconcat, Delim, Concat).
	


% Computes chains of embedded functions, functors separated by '!'
% Example: 
%	for input:   [sk15,[sk11,[sk17,[sk11,[sk15,[sk11,[sk15,[sk16,a]]]]],[sk14,[sk11,[sk15,[sk11,[sk15,[sk16,a]]]]]]]]]
%	output: 	 ['sk15!sk11!sk17!sk11!sk15!sk11!sk15!sk16!a', 'sk15!sk11!sk17!sk14!sk11!sk15!sk11!sk15!sk16!a']
% Variables:
%	i1: predicate argument which is a function
%	o2: list of functor embeddings, each element being a concatenated atom of functors with '!' as delimiter
f_embedding(F, F_Chains):-
	functions_to_push([], [F], F_Chains).


functions_to_push(InChains, [], InChains):-!.
functions_to_push(InChains, Functions, OutChains):-
	maplist(push_f_head, Functions, PFs, PCs),
	append(PFs, NFs),
	sort(NFs, NewPushed),
	append(PCs, PCs2),
	append(PCs2,InChains, NChains),
	sort(NChains, NewChains),
	!,functions_to_push(NewChains, NewPushed, OutChains).


% Diminishes a deep level function by concatenating first functor with second level functors
% Variables:
%	i1: function functor
%	i2: arguments of i1
%	o3: list of arguments of i1 with functor replaced and used as functor for next level arguments
%	o4: list of terminated functor chains
push_f_head([F1|F1Args],F1F2Args,F1F2):-
	push_f_head2(F1,F1Args,[],F1F2Args,[],F1F2),!.
push_f_head2(_,[],InL,InL,InE,InE):-!.
push_f_head2(F,[A|T],InL,OutL,InE,OutE):-
	atom(A),
	atomic_list_concat([F, !, A], FA),
	!,push_f_head2(F,T,InL,OutL,[FA|InE],OutE).
push_f_head2(F,[[A|AL]|T],InL,OutL,InE,OutE):-
	atomic_list_concat([F, !, A], FA),
	!,push_f_head2(F,T,[[FA|AL]|InL],OutL,InE,OutE).
push_f_head2(F,[_|T],InL,OutL,InE,OutE):-
	!,push_f_head2(F,T,InL,OutL,InE,OutE).


% Generates an atom as concatenated prefixed numbered nested list members with their depth, and computes the sum
% Variables:
%	i1:	input list
%	o2: prefixed members atom
%	o3:	sum
mnld(H, Out, Sum):-
	findall(X, mnld2(X, 1, H), Xs),
	msort(Xs, XsS),
	reverse(XsS, XsR),
	atomic_list_concat(XsR, Out),
	maplist(atom_number, Xs, PN),
	sum_list(PN, Sum),!.

% prefixes non-list elements of a nested list with the depth of the list (up to 99 levels reliably for sorting)
% Variables:
%	o1: element of a result list
%	i2: depth level (predicate must be initially called with integer 1)
%	i3: list to process
mnld2(NH,N,[H|_]):-
	\+is_list(H),
	\+var(H),
	N<10,
	atomic_list_concat(['0',N,H],NH).
mnld2(NH,N,[H|_]):-
	\+is_list(H),
	\+var(H),
	N>=10,
	atomic_list_concat([N,H],NH).
mnld2(X,N,[H|_]):-
	is_list(H),
	NN is N+1,
	mnld2(X,NN,H).
mnld2(X,N,[_|T]):-mnld2(X,N,T).





replace_nth1(List, Index, OldElem, NewElem, NewList) :-
   % predicate works forward: Index,List -> OldElem, Transfer
   nth1(Index,List,OldElem,Transfer),
   % predicate works backwards: Index,NewElem,Transfer -> NewList
   nth1(Index,NewList,NewElem,Transfer).


increment(C,Y):-					%% i, o	%% increment the counter identified by C
	counterValue(C,X),						%% retrieve the value of counter C
	retract(counter(C,X)),					%% delete counter C and its value
	plus(X,1,Y),							%% add 1 to the value of what was counter C
	asserta(counter(C,Y)),!.				%% recreate the counter with the new value

decrement(C,Y):-					%% i, o	%% decrement the counter identified by C
	counterValue(C,X),						%% retrieve the value of counter C
	retract(counter(C,X)),					%% delete counter C and its value
	plus(X,-1,Y),							%% substract 1 from the value of what was counter C
	asserta(counter(C,Y)),!.				%% recreate the counter with the new value

counterValue(C, Value):-			%% i,o	%% retrieves the value of a counter			
	counter(C,Value),!.						%% if the counter exist, take the value
counterValue(C, 0):-						%% if the counter does not yet exist, return zero
	asserta(counter(C,0)),!.					%% after creating the counter

asserta_once(A):-call(A),!.
asserta_once(A):-acyclic_term(A),asserta(A),!.
asserta_once(A):-writeln(A),trace,!.

	
assertz_once(A):-call(A),!.
assertz_once(A):-acyclic_term(A),assertz(A),!.
assertz_once(A):-writeln(A),trace,!.


% Pad a positive number with leading zero's, converting it into an atom
% Variables:
%	i1:	number to pad				(e.g. 12)
%	i2:	total length of result		(e.g. 5)
%	o3:	padded number as atom		(e.g. '00012')
pad_nat_num(Number, PadLength, PaddedNumber):-
	number_digits(Number, NumberOfDigits),			% compute number of digits in the number
	plus(ToPad, NumberOfDigits,	PadLength),			% compute number of leading zero's to add
	length(Prefix, ToPad),							% create an uninstantiated list of length ToPad
	maplist(=('0'), Prefix),						% fill the list with zero's in atom formatted
	append(Prefix, [Number], PadList),				% add the number at the end of the leading zero list
	atomic_list_concat(PadList, PaddedNumber).		% create the padded number as atom


% Compute the number of digits in a number
% Variables:
%	i1:	the number									(e.g. 12.3)
%	o2:	the number of digits in the number in i1	(e.g. 4)
number_digits(Number, NumberOfDigits):-
	atom_number(Atom, Number),						% convert the number to an atom
	atom_length(Atom, NumberOfDigits).				% return the number of characters in the atom			


replace(V, NV, W, NV) :-
    % substitute instantiated vars 
	V==W,
    !.     
replace(V, V,_,_) :-
    % pass other vars through 
    var(V), !.     
replace(A, A,_,_) :- 
    % pass atoms through 
    atomic(A), !.
replace([], [],_,_) :- 
    % pass empty lists through
    !.
replace([X|Xs], [Y|Ys], V, NV) :-
    % recursively enter non-empty lists
    !, 
    replace(X, Y, V, NV),
    replace(Xs, Ys, V, NV).
/*replace(T, NT, V, NV) :-
    % finally, recursively enter any as yet unmatched compound term
    T =.. [F|AL],
    replace(AL, NAL, V, NV),
    NT =.. [F|NAL].
*/

% i,i,i,o
exact_member_pos([], _, In, Out):-
	reverse(In, Out),!.
exact_member_pos([H|Rest], Comp, In, Out):-
%	H == Comp,
	subsumes_term(Comp,H),
	!, exact_member_pos(Rest, Comp, In, Out). 
exact_member_pos([H|Rest], Comp, In, Out):-
	!, exact_member_pos(Rest, Comp, [H|In], Out). 

% i
sym_sum(A,B):-
	subsumes_term(A,B),
	subsumes_term(B,A),!.
sym_sum(A,B):-
	is_list(A), sort(A,AL),
	is_list(B), sort(A,BL),
	sym_sum_list(AL,BL),!.

sym_sum_list([],[]):-!.
sym_sum_list([H1|T1],[H2|T2]):-
	sym_sum(H1,H2),
	!,sym_sum_list(T1,T2).

% i,o
list_depth([],1).
list_depth([H|T],R):-
	\+is_list(H),
	!,list_depth(T,R).
list_depth([H|T],R):- 
	list_depth(H,R1), 
	list_depth(T,R2), 
	R3 is R1+1,
	max_list([R3,R2],R).



% Grounds all variables in a (nested) (clause) list using 'v_1', 'v_2', ...
% Variables:
%	i1:	(disjunction) list
%	o2: ground version
ground_clause(Clause,Clause):-							% return input when ...
	ground(Clause),!.									%	already ground
ground_clause(Clause,GroundClause):-
	duplicate_term(Clause,D),
	listGrounder(D,[],Out),								% ground all variables by '_N' where N is the internal variable number
	findall( X,											% collect all these ground variables 
			 ( sub_term(X, Out),
			   atom(X),
			   atom_concat('_', _, X) ),
			 Xs),
	sort(Xs, Xss),
	length(Xss, LXs),
	numlist(1, LXs, NL),								% create a list [1, 2, ...] with length = number of ground variables
	maplist(atom_concat('v_'), NL, V_atoms),			% create a list ['v_1', 'v_2', ...]
	listGrounder2(Xss, V_atoms, Out, [], GroundClause),	% replace the internal var numbers with the 'v_N' versions
	!.


% Variables
%	i1: list of terms to ground
%	i2: in-accumulator
%	o3: out-accumulator, on exit containing i1 with all variables grounded as atoms
listGrounder([], In, Out):-
	reverse(In, Out),!.
listGrounder([H|R], In, Out):-
	( is_list(H)							% process list with at least one member that is a list 
	  	->	listGrounder(H,[],OutH)
	; atom(H)
		->	OutH = H
	; term_to_atom(H, OutH)					% atomize any other term
	),
	!, listGrounder(R, [OutH|In], Out).


listGrounder2(_, _, [], In, Out):-
	reverse(In, Out),!.
listGrounder2(With, What, [H|R], In, Out):-
	( is_list(H)							
	  	->	listGrounder2(With, What, H, [], OutH)
	; nth1(N, With, H)
		->	nth1(N, What, OutH)
	; OutH = H	
	),
	!, listGrounder2(With, What, R, [OutH|In], Out).


remove(Lin,Elem,Lout) :-
   append([Front,[Elem],Back],Lin),  % decompose
   append([Front,Back],Lout).        % recompose

%% Return greatest number in heterogenous list
% Variables:
%	i1: a list with members of any Prolog datatype
%	o2: the greatest number found in i1, if none: 0
mixed_list_max_number(List,Max):-
	mae(List,0,Max),
	!.
mae([],In,In):-!.
mae([H|R],In,Out):-
	number(H),
	H > In,
	!,mae(R,H,Out).
mae([_|R],In,Out):-
	!,mae(R,In,Out).

